<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>dsem model description ‚Ä¢ dsem</title>
<script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="../deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet">
<script src="../deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><link href="../deps/font-awesome-6.5.2/css/all.min.css" rel="stylesheet">
<link href="../deps/font-awesome-6.5.2/css/v4-shims.min.css" rel="stylesheet">
<script src="../deps/headroom-0.11.0/headroom.min.js"></script><script src="../deps/headroom-0.11.0/jQuery.headroom.min.js"></script><script src="../deps/bootstrap-toc-1.0.1/bootstrap-toc.min.js"></script><script src="../deps/clipboard.js-2.0.11/clipboard.min.js"></script><script src="../deps/search-1.0.0/autocomplete.jquery.min.js"></script><script src="../deps/search-1.0.0/fuse.min.js"></script><script src="../deps/search-1.0.0/mark.min.js"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="dsem model description">
</head>
<body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>


    <nav class="navbar navbar-expand-lg fixed-top bg-light" data-bs-theme="light" aria-label="Site navigation"><div class="container">

    <a class="navbar-brand me-2" href="../index.html">dsem</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">1.6.0</small>


    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto">
<li class="nav-item"><a class="nav-link" href="../reference/index.html">Reference</a></li>
<li class="active nav-item dropdown">
  <button class="nav-link dropdown-toggle" type="button" id="dropdown-articles" data-bs-toggle="dropdown" aria-expanded="false" aria-haspopup="true">Articles</button>
  <ul class="dropdown-menu" aria-labelledby="dropdown-articles">
<li><a class="dropdown-item" href="../articles/model-description.html">dsem model description</a></li>
    <li><a class="dropdown-item" href="../articles/features.html">Demonstration of selected features</a></li>
    <li><a class="dropdown-item" href="../articles/dynamic_factor_analysis.html">Dynamic factor analysis</a></li>
    <li><a class="dropdown-item" href="../articles/spatial_diffusion.html">Spatial diffusion</a></li>
  </ul>
</li>
<li class="nav-item"><a class="nav-link" href="../news/index.html">Changelog</a></li>
      </ul>
<ul class="navbar-nav">
<li class="nav-item"><form class="form-inline" role="search">
 <input class="form-control" type="search" name="search-input" id="search-input" autocomplete="off" aria-label="Search site" placeholder="Search for" data-search-index="../search.json">
</form></li>
<li class="nav-item"><a class="external-link nav-link" href="https://github.com/James-Thorson-NOAA/dsem/" aria-label="GitHub"><span class="fa fab fa-github fa-lg"></span></a></li>
      </ul>
</div>


  </div>
</nav><div class="container template-article">




<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">

      <h1>dsem model description</h1>
                        <h4 data-toc-skip class="author">James T.
Thorson</h4>
            
      
      <small class="dont-index">Source: <a href="https://github.com/James-Thorson-NOAA/dsem/blob/main/vignettes/model-description.Rmd" class="external-link"><code>vignettes/model-description.Rmd</code></a></small>
      <div class="d-none name"><code>model-description.Rmd</code></div>
    </div>

    
    
<!-- math bold nonitalic -->
<!-- math nonitalic -->
<div class="section level2">
<h2 id="dynamic-structural-equation-models">Dynamic structural equation models<a class="anchor" aria-label="anchor" href="#dynamic-structural-equation-models"></a>
</h2>
<p>dsem involves specifying a dynamic structural equation model (DSEM).
This DSEM be viewed either:</p>
<ol style="list-style-type: decimal">
<li>
<em>Weak interpretation</em>: as an expressive interface to
parameterize the correlation among variables, using as many or few
parameters as might be appropriate; or</li>
<li>
<em>Strong interpretation</em>: as a structural causal model,
allowing predictions about the consequence of counterfactual changes to
the system.</li>
</ol>
<p>We introduce DSEM first from the perspective of a software user
(i.e., the interface) and then from the perspective of a statistician
(i.e., the equations and their interpretation).</p>
<div class="section level4">
<h4 id="viewpoint-1-software-interface">Viewpoint 1: Software interface<a class="anchor" aria-label="anchor" href="#viewpoint-1-software-interface"></a>
</h4>
<p>To specify a DSEM, the user uses <em>arrow-and-lag notation</em>,
based on <em>arrow notation</em> derived from package <code>sem</code>.
For example, to specify a first-order autoregressive process with
variable
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math>
this involves:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a>x <span class="ot">-&gt;</span> x, <span class="dv">1</span>, ar1</span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a>x <span class="ot">&lt;-</span><span class="er">&gt;</span> x, <span class="dv">0</span>, sd</span></code></pre></div>
<p>This then estimates a single parameter representing first-order
autoregression (represented with a one-headed arrow), as well as the
Cholesky decomposition of the exogenous covariance of of model variables
(specified with two-headed arrows). See <code><a href="../reference/make_dsem_ram.html">?make_dsem_ram</a></code>
Details section for more details about syntax.</p>
<p>If there were four time-intervals
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo>=</mo><mn>4</mn></mrow><annotation encoding="application/x-tex">T=4</annotation></semantics></math>)
this would then result in the path matrix:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ùêè</mi><mrow><mi mathvariant="normal">j</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">t</mi></mrow></msub><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><mtable><mtr><mtd columnalign="center" style="text-align: center"><mn>0</mn></mtd><mtd columnalign="center" style="text-align: center"><mn>0</mn></mtd><mtd columnalign="center" style="text-align: center"><mn>0</mn></mtd><mtd columnalign="center" style="text-align: center"><mn>0</mn></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><mi>œÅ</mi></mtd><mtd columnalign="center" style="text-align: center"><mn>0</mn></mtd><mtd columnalign="center" style="text-align: center"><mn>0</mn></mtd><mtd columnalign="center" style="text-align: center"><mn>0</mn></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><mn>0</mn></mtd><mtd columnalign="center" style="text-align: center"><mi>œÅ</mi></mtd><mtd columnalign="center" style="text-align: center"><mn>0</mn></mtd><mtd columnalign="center" style="text-align: center"><mn>0</mn></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><mn>0</mn></mtd><mtd columnalign="center" style="text-align: center"><mn>0</mn></mtd><mtd columnalign="center" style="text-align: center"><mi>œÅ</mi></mtd><mtd columnalign="center" style="text-align: center"><mn>0</mn></mtd></mtr></mtable><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">
\mathbf P_{\mathrm{joint}} = 
\begin{pmatrix}
  0 &amp; 0 &amp; 0 &amp; 0 \\
  \rho &amp; 0 &amp; 0 &amp; 0 \\
  0 &amp; \rho &amp; 0 &amp; 0 \\
  0 &amp; 0 &amp; \rho &amp; 0 
\end{pmatrix}
</annotation></semantics></math> This joint path matrix then represents
the partial effect of each variable and time (column) on each other
variable and time (row).</p>
<p>DSEM interactions can be as complicated or simple as desired, and can
include:</p>
<ol style="list-style-type: decimal">
<li>Latent variables and loops (i.e., they are not restricted to
directed acyclic graphs);</li>
<li>Values that are fixed a priori, where the
<code>parameter_name</code> is provided as <code>NA</code> and the
starting value that follows is the fixed value;</li>
<li>Values that are mirrored among path coefficients, where the same
<code>parameter_name</code> is provided for multiple rows of the text
file.</li>
</ol>
<p>The user also specifies a distribution for measurement errors for
each variable using arguement <code>family</code>, and whether each
time-series starts from its stationary distribution or from some
non-equilibrium initial condition using argument
<code>estimate_delta0</code>. If the latter is specified, then variables
will tend to converge back on the stationary distribution at a rate that
is determined by estimated parameters.</p>
</div>
<div class="section level4">
<h4 id="viewpoint-2-mathematical-details">Viewpoint 2: Mathematical details<a class="anchor" aria-label="anchor" href="#viewpoint-2-mathematical-details"></a>
</h4>
<p>The DSEM defines a generalized linear mixed model (GLMM) for a
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo>√ó</mo><mi>J</mi></mrow><annotation encoding="application/x-tex">T \times J</annotation></semantics></math>
matrix
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ùêò</mi><annotation encoding="application/x-tex">\mathbf{Y}</annotation></semantics></math>,
where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>y</mi><mrow><mi>t</mi><mi>j</mi></mrow></msub><annotation encoding="application/x-tex">y_{tj}</annotation></semantics></math>
is the measurement in time
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>t</mi><annotation encoding="application/x-tex">t</annotation></semantics></math>
for variable
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>j</mi><annotation encoding="application/x-tex">j</annotation></semantics></math>.
This measurement matrix can include missing values
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>y</mi><mrow><mi>t</mi><mi>j</mi></mrow></msub><mo>=</mo><mrow><mi mathvariant="normal">N</mi><mi mathvariant="normal">A</mi></mrow></mrow><annotation encoding="application/x-tex">y_{tj} = \mathrm{NA}</annotation></semantics></math>,
and it will estimate a
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo>√ó</mo><mi>J</mi></mrow><annotation encoding="application/x-tex">T \times J</annotation></semantics></math>
matrix of latent states
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ùêó</mi><annotation encoding="application/x-tex">\mathbf{X}</annotation></semantics></math>
for all modeled times and variables.</p>
<p>DSEM includes multiple distribution for measurement errors. For
example, if the user specifies <code>family[j] = "fixed"</code>
then:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>y</mi><mrow><mi>t</mi><mi>j</mi></mrow></msub><mo>=</mo><msub><mi>x</mi><mrow><mi>t</mi><mi>j</mi></mrow></msub><mo>+</mo><msub><mi>d</mi><mrow><mi>t</mi><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">
y_{tj} = x_{tj} + d_{tj}
</annotation></semantics></math> for all years. Alternatively, if the
user specifies <code>family[j] = "normal"</code> then:
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>y</mi><mrow><mi>t</mi><mi>j</mi></mrow></msub><mo>‚àº</mo><mrow><mi mathvariant="normal">N</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">r</mi><mi mathvariant="normal">m</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">l</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>x</mi><mrow><mi>t</mi><mi>j</mi></mrow></msub><mo>+</mo><msub><mi>d</mi><mrow><mi>t</mi><mi>j</mi></mrow></msub><mo>,</mo><msup><msub><mi>œÉ</mi><mi>j</mi></msub><mn>2</mn></msup><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">
y_{tj} \sim \mathrm{Normal}( x_{tj} + d_{tj}, {\sigma_j}^2)
</annotation></semantics></math> and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><msub><mi>œÉ</mi><mi>j</mi></msub><mn>2</mn></msup><annotation encoding="application/x-tex">{\sigma_j}^2</annotation></semantics></math>
is then included as an estimated parameter. These expressions include
the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo>√ó</mo><mi>J</mi></mrow><annotation encoding="application/x-tex">T \times J</annotation></semantics></math>
matrix
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ùêÉ</mi><annotation encoding="application/x-tex">\mathbf D</annotation></semantics></math>
representing the ongoing impact of initial conditions
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>d</mi><mrow><mi>t</mi><mi>j</mi></mrow></msub><annotation encoding="application/x-tex">d_{tj}</annotation></semantics></math>
for each variable and year, as explained in detail below.</p>
<p>The specified DSEM then results in Gaussian Markov random field for
latent states:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">v</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">c</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>ùêó</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>‚àº</mo><mrow><mi mathvariant="normal">G</mi><mi mathvariant="normal">M</mi><mi mathvariant="normal">R</mi><mi mathvariant="normal">F</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><msub><mrow><mn>ùüé</mn><mo mathvariant="bold">,</mo><mi>ùêê</mi></mrow><mrow><mi mathvariant="normal">j</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">t</mi></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">
\mathrm{vec}(\mathbf X) \sim \mathrm{GMRF}(\mathbf{0, Q}_{\mathrm{joint}})
</annotation></semantics></math> where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ùêê</mi><mrow><mi mathvariant="normal">j</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">t</mi></mrow></msub><annotation encoding="application/x-tex">\mathbf Q_{\mathrm{joint}}</annotation></semantics></math>
is a
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mi>J</mi><mo>√ó</mo><mi>T</mi><mi>J</mi></mrow><annotation encoding="application/x-tex">TJ \times TJ</annotation></semantics></math>
precision matrix such that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><msub><mi>ùêê</mi><mrow><mi mathvariant="normal">j</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">t</mi></mrow></msub><mrow><mo>‚àí</mo><mn>1</mn></mrow></msup><annotation encoding="application/x-tex">\mathbf{Q_{\mathrm{joint}}}^{-1}</annotation></semantics></math>
is the estimated covariance among latent states. This joint precision is
itself constructed from a joint path matrix
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ùêè</mi><mrow><mi mathvariant="normal">j</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">t</mi></mrow></msub><annotation encoding="application/x-tex">\mathbf P_{\mathrm{joint}}</annotation></semantics></math>
and a joint matrix of exogenous covariance
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ùêÜ</mi><mrow><mi mathvariant="normal">j</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">t</mi></mrow></msub><annotation encoding="application/x-tex">\mathbf G_{\mathrm{joint}}</annotation></semantics></math>:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ùêê</mi><mrow><mi mathvariant="normal">j</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">t</mi></mrow></msub><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><msup><msub><mrow><mi>ùêà</mi><mo mathvariant="bold">‚àí</mo><mi>ùêè</mi></mrow><mrow><mi mathvariant="normal">j</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">t</mi></mrow></msub><mi>T</mi></msup><mo stretchy="true" form="postfix">)</mo></mrow><msubsup><mi>ùêÜ</mi><mrow><mi mathvariant="normal">j</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">t</mi></mrow><mrow><mo>‚àí</mo><mn>1</mn></mrow></msubsup><msubsup><mi>ùêÜ</mi><mrow><mi mathvariant="normal">j</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">t</mi></mrow><mrow><mo>‚àí</mo><mi>T</mi></mrow></msubsup><mrow><mo stretchy="true" form="prefix">(</mo><mrow><mi>ùêà</mi><mo mathvariant="bold">‚àí</mo><msub><mi>ùêè</mi><mrow><mi mathvariant="normal">j</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">t</mi></mrow></msub></mrow><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">
\mathbf Q_{\mathrm{joint}} = ({\mathbf{I - P}_{\mathrm{joint}}}^T) \mathbf G_{\mathrm{joint}}^{-1} \mathbf G_{\mathrm{joint}}^{-T} (\mathbf{I - P_{\mathrm{joint}}})
</annotation></semantics></math></p>
</div>
<div class="section level4">
<h4 id="constructing-the-joint-path-matrix">Constructing the joint path matrix<a class="anchor" aria-label="anchor" href="#constructing-the-joint-path-matrix"></a>
</h4>
<p>The joint path matrix is itself constructed by summing across lagged
and simultaneous effects. Say we specify a model with
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">K=2</annotation></semantics></math>
one-headed arrows. For each one-headed arrow, we define a
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>J</mi><mo>√ó</mo><mi>J</mi></mrow><annotation encoding="application/x-tex">J \times J</annotation></semantics></math>
path matrix
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ùêè</mi><mi>k</mi></msub><annotation encoding="application/x-tex">\mathbf P_k</annotation></semantics></math>
and a lag matrix
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ùêã</mi><mi>k</mi></msub><annotation encoding="application/x-tex">\mathbf L_k</annotation></semantics></math>.
For example, in a model with
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>J</mi><mo>=</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">J=3</annotation></semantics></math>
variables
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><mi>A</mi><mo>,</mo><mi>B</mi><mo>,</mo><mi>C</mi><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(A,B,C)</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo>=</mo><mn>4</mn></mrow><annotation encoding="application/x-tex">T=4</annotation></semantics></math>
times, and specifying
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">K=2</annotation></semantics></math>
one-headed arrows:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" tabindex="-1"></a>A <span class="ot">-&gt;</span> B, <span class="dv">0</span>, b_AB</span>
<span id="cb2-2"><a href="#cb2-2" tabindex="-1"></a>B <span class="ot">-&gt;</span> C, <span class="dv">1</span>, b_BC</span></code></pre></div>
<p>this then results two path matrices:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ùêè</mi><mn>1</mn></msub><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><mtable><mtr><mtd columnalign="center" style="text-align: center"><mn>0</mn></mtd><mtd columnalign="center" style="text-align: center"><mn>0</mn></mtd><mtd columnalign="center" style="text-align: center"><mn>0</mn></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><msub><mi>b</mi><mrow><mi>A</mi><mi>B</mi></mrow></msub></mtd><mtd columnalign="center" style="text-align: center"><mn>0</mn></mtd><mtd columnalign="center" style="text-align: center"><mn>0</mn></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><mn>0</mn></mtd><mtd columnalign="center" style="text-align: center"><mn>0</mn></mtd><mtd columnalign="center" style="text-align: center"><mn>0</mn></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"></mtd></mtr></mtable><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">
\mathbf P_1 = 
\begin{pmatrix}
  0 &amp; 0 &amp; 0 \\
  b_{AB} &amp; 0 &amp; 0 \\
  0 &amp; 0 &amp; 0 \\
\end{pmatrix}
</annotation></semantics></math> and
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ùêè</mi><mn>2</mn></msub><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><mtable><mtr><mtd columnalign="center" style="text-align: center"><mn>0</mn></mtd><mtd columnalign="center" style="text-align: center"><mn>0</mn></mtd><mtd columnalign="center" style="text-align: center"><mn>0</mn></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><mn>0</mn></mtd><mtd columnalign="center" style="text-align: center"><mn>0</mn></mtd><mtd columnalign="center" style="text-align: center"><mn>0</mn></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><mn>0</mn></mtd><mtd columnalign="center" style="text-align: center"><msub><mi>b</mi><mrow><mi>B</mi><mi>C</mi></mrow></msub></mtd><mtd columnalign="center" style="text-align: center"><mn>0</mn></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"></mtd></mtr></mtable><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">
\mathbf P_2 = 
\begin{pmatrix}
  0 &amp; 0 &amp; 0 \\
  0 &amp; 0 &amp; 0 \\
  0 &amp; b_{BC} &amp; 0 \\
\end{pmatrix}
</annotation></semantics></math> with corresponding lag matrices</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ùêã</mi><mn>1</mn></msub><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><mtable><mtr><mtd columnalign="center" style="text-align: center"><mn>1</mn></mtd><mtd columnalign="center" style="text-align: center"><mn>0</mn></mtd><mtd columnalign="center" style="text-align: center"><mn>0</mn></mtd><mtd columnalign="center" style="text-align: center"><mn>0</mn></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><mn>0</mn></mtd><mtd columnalign="center" style="text-align: center"><mn>1</mn></mtd><mtd columnalign="center" style="text-align: center"><mn>0</mn></mtd><mtd columnalign="center" style="text-align: center"><mn>0</mn></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><mn>0</mn></mtd><mtd columnalign="center" style="text-align: center"><mn>0</mn></mtd><mtd columnalign="center" style="text-align: center"><mn>1</mn></mtd><mtd columnalign="center" style="text-align: center"><mn>0</mn></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><mn>0</mn></mtd><mtd columnalign="center" style="text-align: center"><mn>0</mn></mtd><mtd columnalign="center" style="text-align: center"><mn>0</mn></mtd><mtd columnalign="center" style="text-align: center"><mn>1</mn></mtd></mtr></mtable><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">
\mathbf L_{1} = 
\begin{pmatrix}
  1 &amp; 0 &amp; 0 &amp; 0 \\
  0 &amp; 1 &amp; 0 &amp; 0 \\
  0 &amp; 0 &amp; 1 &amp; 0 \\
  0 &amp; 0 &amp; 0 &amp; 1 
\end{pmatrix}
</annotation></semantics></math> and
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ùêã</mi><mn>2</mn></msub><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><mtable><mtr><mtd columnalign="center" style="text-align: center"><mn>0</mn></mtd><mtd columnalign="center" style="text-align: center"><mn>0</mn></mtd><mtd columnalign="center" style="text-align: center"><mn>0</mn></mtd><mtd columnalign="center" style="text-align: center"><mn>0</mn></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><mn>1</mn></mtd><mtd columnalign="center" style="text-align: center"><mn>0</mn></mtd><mtd columnalign="center" style="text-align: center"><mn>0</mn></mtd><mtd columnalign="center" style="text-align: center"><mn>0</mn></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><mn>0</mn></mtd><mtd columnalign="center" style="text-align: center"><mn>1</mn></mtd><mtd columnalign="center" style="text-align: center"><mn>0</mn></mtd><mtd columnalign="center" style="text-align: center"><mn>0</mn></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><mn>0</mn></mtd><mtd columnalign="center" style="text-align: center"><mn>0</mn></mtd><mtd columnalign="center" style="text-align: center"><mn>1</mn></mtd><mtd columnalign="center" style="text-align: center"><mn>0</mn></mtd></mtr></mtable><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">
\mathbf L_{2} = 
\begin{pmatrix}
  0 &amp; 0 &amp; 0 &amp; 0 \\
  1 &amp; 0 &amp; 0 &amp; 0 \\
  0 &amp; 1 &amp; 0 &amp; 0 \\
  0 &amp; 0 &amp; 1 &amp; 0 
\end{pmatrix}
</annotation></semantics></math> We then sum across the Kronecker
product of these components to obtain the joint path matrix:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ùêè</mi><mrow><mi mathvariant="normal">j</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">t</mi></mrow></msub><mo>=</mo><munderover><mo>‚àë</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mi>K</mi></munderover><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>ùêã</mi><mi>k</mi></msub><mo>‚äó</mo><msub><mi>ùêè</mi><mi>k</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">
\mathbf P_{\mathrm{joint}} = \sum_{k=1}^{K}(\mathbf L_k \otimes \mathbf P_k)
</annotation></semantics></math> where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>‚äó</mo><annotation encoding="application/x-tex">\otimes</annotation></semantics></math>
is the Kronecker product. Similarly, the exogenous covariance is similar
constructed from a Kronecker product, although we assume that all
covariance is simultaneous (i.e., no lags are allowed for two-headed
arrows):</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ùêÜ</mi><mrow><mi mathvariant="normal">j</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">t</mi></mrow></msub><mo>=</mo><mi>ùêà</mi><mo>‚äó</mo><mi>ùêÜ</mi></mrow><annotation encoding="application/x-tex">
\mathbf G_{\mathrm{joint}} = \mathbf I \otimes \mathbf G
</annotation></semantics></math></p>
<p>These matrices are define a simultaneous equation model:</p>
<p><span class="math display">$$
\mathrm{vec}(\mathbf X) = \mathbf P_{\mathrm{joint}}
\mathrm{vec}(\mathbf X) + \mathbf\epsilon \\
\mathbf\epsilon \sim \mathrm{MVN}( \mathbf 0,
\mathbf{G_{\mathrm{joint}}}^T \mathbf G_{\mathrm{joint}} )
$$</span> and the precision matrix can be derived from this simultaneous
equation.</p>
</div>
<div class="section level4">
<h4 id="initial-conditions-and-total-effects">Initial conditions and total effects<a class="anchor" aria-label="anchor" href="#initial-conditions-and-total-effects"></a>
</h4>
<p>Imagine we have some exogenous intervention that caused a
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo>√ó</mo><mi>J</mi></mrow><annotation encoding="application/x-tex">T \times J</annotation></semantics></math>
matrix of changes
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ùêÇ</mi><annotation encoding="application/x-tex">\mathbf C</annotation></semantics></math>.
The total effect of this exogenous intervention would then be
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mrow><mo stretchy="true" form="prefix">(</mo><msub><mrow><mi>ùêà</mi><mo mathvariant="bold">‚àí</mo><mi>ùêè</mi></mrow><mrow><mi mathvariant="normal">j</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">t</mi></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mo>‚àí</mo><mn>1</mn></mrow></msup><mrow><mi mathvariant="normal">v</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">c</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>ùêÇ</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">(\mathbf{I - P}_{\mathrm{joint}})^{-1} \mathrm{vec}(\mathbf C)</annotation></semantics></math>,
and we can calculate any total effect using this matrix inverse
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mrow><mo stretchy="true" form="prefix">(</mo><msub><mrow><mi>ùêà</mi><mo mathvariant="bold">‚àí</mo><mi>ùêè</mi></mrow><mrow><mi mathvariant="normal">j</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">t</mi></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mo>‚àí</mo><mn>1</mn></mrow></msup><annotation encoding="application/x-tex">(\mathbf{I - P}_{\mathrm{joint}})^{-1}</annotation></semantics></math>
(called the ‚ÄúLeontief matrix‚Äù). To see this, consider that the
first-order effect of change
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ùêÇ</mi><annotation encoding="application/x-tex">\mathbf C</annotation></semantics></math>
is
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ùêè</mi><mrow><mi mathvariant="normal">j</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">t</mi></mrow></msub><mrow><mi mathvariant="normal">v</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">c</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>ùêÇ</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\mathbf P_{\mathrm{joint}} \mathrm{vec}(\mathbf C)</annotation></semantics></math>,
but this response then in turn causes a second-order effect
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><msub><mi>ùêè</mi><mrow><mi mathvariant="normal">j</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">t</mi></mrow></msub><mn>2</mn></msup><mrow><mi mathvariant="normal">v</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">c</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>ùêÇ</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\mathbf{P_{\mathrm{joint}}}^2 \mathrm{vec}(\mathbf C)</annotation></semantics></math>,
and so on. The total effect is therefore:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><munderover><mo>‚àë</mo><mrow><mi>l</mi><mo>=</mo><mn>1</mn></mrow><mo accent="false">‚àû</mo></munderover><msup><msub><mi>ùêè</mi><mrow><mi mathvariant="normal">j</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">t</mi></mrow></msub><mi>l</mi></msup><mo>=</mo><msup><mrow><mo stretchy="true" form="prefix">(</mo><msub><mrow><mi>ùêà</mi><mo mathvariant="bold">‚àí</mo><mi>ùêè</mi></mrow><mrow><mi mathvariant="normal">j</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">t</mi></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mo>‚àí</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">
\sum_{l=1}^{\infty} \mathbf{P_{\mathrm{joint}}}^l = (\mathbf{I - P}_{\mathrm{joint}})^{-1}
</annotation></semantics></math> where this power-series of direct and
indirect effects then results in the Leontief matrix (as long as the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ùêà</mi><mo mathvariant="bold">‚àí</mo><mi>ùêè</mi></mrow><annotation encoding="application/x-tex">\mathbf{I - P}</annotation></semantics></math>
is invertible).</p>
<p>We can use this expression to calculate the matrix
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ùêÉ</mi><annotation encoding="application/x-tex">\mathbf D</annotation></semantics></math>
represents the ongoing effect of initial conditions. It is constructed
from a
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>J</mi><annotation encoding="application/x-tex">J</annotation></semantics></math>
length vector of estimated initial conditions
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ùõÖ</mi><mn>1</mn></msub><annotation encoding="application/x-tex">\mathbf\delta_1</annotation></semantics></math>
in time
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">t=1</annotation></semantics></math>,
and we construct a
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo>√ó</mo><mi>J</mi></mrow><annotation encoding="application/x-tex">T \times J</annotation></semantics></math>
matrix
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ùö´</mi><annotation encoding="application/x-tex">\mathbf\Delta</annotation></semantics></math>
where the first row (corresponding to year
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">t=1</annotation></semantics></math>)
is
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ùõÖ</mi><mn>1</mn></msub><annotation encoding="application/x-tex">\mathbf\delta_1</annotation></semantics></math>
and all other elements are
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>0</mn><annotation encoding="application/x-tex">0</annotation></semantics></math>.
The ongoing effect of initial conditions can then be calculated as:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">v</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">c</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>ùêÉ</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msup><mrow><mo stretchy="true" form="prefix">(</mo><msub><mrow><mi>ùêà</mi><mo mathvariant="bold">‚àí</mo><mi>ùêè</mi></mrow><mrow><mi mathvariant="normal">j</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">t</mi></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mo>‚àí</mo><mn>1</mn></mrow></msup><mrow><mi mathvariant="normal">v</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">c</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>ùö´</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">
\mathrm{vec}(\mathbf D) = (\mathbf{I - P}_{\mathrm{joint}})^{-1} \mathrm{vec}(\mathbf\Delta)
</annotation></semantics></math> Calculating the effect of initial
conditions is in a sense the total effect of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ùõÖ</mi><mn>1</mn></msub><annotation encoding="application/x-tex">\mathbf\delta_1</annotation></semantics></math>
in year
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">t=1</annotation></semantics></math>
on subsequent years. Calculating the effect
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ùêÉ</mi><annotation encoding="application/x-tex">\mathbf D</annotation></semantics></math>
of initial conditions involves inverting
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mrow><mi>ùêà</mi><mo mathvariant="bold">‚àí</mo><mi>ùêè</mi></mrow><mrow><mi mathvariant="normal">j</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">t</mi></mrow></msub><annotation encoding="application/x-tex">\mathbf{I - P}_{\mathrm{joint}}</annotation></semantics></math>,
but this is computationally efficient using a sparse LU
decomposition.</p>
</div>
<div class="section level4">
<h4 id="constant-conditional-vs--marginal-variance">Constant conditional vs.¬†marginal variance<a class="anchor" aria-label="anchor" href="#constant-conditional-vs--marginal-variance"></a>
</h4>
<p>We have defined the joint precision for a GMRF based on a path matrix
and matrix of exogenous covariances. The exogenous (or conditional)
variances are stationary for each variable over time, and some path
matrices will result in a nonstationary marginal variance. To see this,
consider a first-order autoregressive process</p>
<div class="sourceCode" id="cb3"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">dsem</span> <span class="op">=</span> <span class="st">" </span></span>
<span><span class="st">x -&gt; x, 1, ar1, 0.8</span></span>
<span><span class="st">x &lt;-&gt; x, 0, sd, 1</span></span>
<span><span class="st">"</span></span></code></pre></div>
<p>We can parse this DSEM and construct the precision using internal
functions:</p>
<div class="sourceCode" id="cb4"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Load package</span></span>
<span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://james-thorson-noaa.github.io/dsem/" class="external-link">dsem</a></span><span class="op">)</span></span>
<span></span>
<span><span class="co"># call dsem without estimating parameters</span></span>
<span><span class="va">out</span> <span class="op">=</span> <span class="fu"><a href="../reference/dsem.html">dsem</a></span><span class="op">(</span></span>
<span>  tsdata <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/ts.html" class="external-link">ts</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/data.frame.html" class="external-link">data.frame</a></span><span class="op">(</span> x <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep</a></span><span class="op">(</span><span class="fl">1</span>,<span class="fl">10</span><span class="op">)</span> <span class="op">)</span><span class="op">)</span>,</span>
<span>  sem <span class="op">=</span> <span class="va">dsem</span>,</span>
<span>  control <span class="op">=</span> <span class="fu"><a href="../reference/dsem_control.html">dsem_control</a></span><span class="op">(</span></span>
<span>    run_model <span class="op">=</span> <span class="cn">FALSE</span>, </span>
<span>    quiet <span class="op">=</span> <span class="cn">TRUE</span></span>
<span>  <span class="op">)</span></span>
<span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Extract covariance</span></span>
<span><span class="va">Sigma1</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/solve.html" class="external-link">solve</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">as.matrix</a></span><span class="op">(</span><span class="va">out</span><span class="op">$</span><span class="va">obj</span><span class="op">$</span><span class="fu">report</span><span class="op">(</span><span class="op">)</span><span class="op">$</span><span class="va">Q_kk</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/plot.html" class="external-link">plot</a></span><span class="op">(</span> x<span class="op">=</span><span class="fl">1</span><span class="op">:</span><span class="fl">10</span>, y <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/diag.html" class="external-link">diag</a></span><span class="op">(</span><span class="va">Sigma1</span><span class="op">)</span>, xlab<span class="op">=</span><span class="st">"time"</span>, </span>
<span>      ylab<span class="op">=</span><span class="st">"Marginal variance"</span>, type<span class="op">=</span><span class="st">"l"</span>, </span>
<span>      ylim <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">0</span>,<span class="fu"><a href="https://rdrr.io/r/base/Extremes.html" class="external-link">max</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/diag.html" class="external-link">diag</a></span><span class="op">(</span><span class="va">Sigma1</span><span class="op">)</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<p><img src="model-description_files/figure-html/unnamed-chunk-4-1.png" width="700"></p>
<p>where we can see that the diagonal of this covariance matrix is
non-constant.</p>
<p>We therefore derive an alternative specification that preserves a
stationary marginal variance by rescaling the exogenous (conditional)
variance.</p>
<p>Specifically, we see that the marginal variance is:</p>
<p><span class="math display">$$
\mathrm{Var}(\mathbf X) = \mathrm{diag}(\mathbf\Sigma) = \mathbf{ L L}^T
\\
\mathbf L = (\mathbf{I - P}_{\mathrm{joint}})^{-1} \mathbf G
$$</span> Given the properties of the Hadamard (elementwise) product,
this can be rewritten as:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">d</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">g</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>ùö∫</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mrow><mrow><mo stretchy="true" form="prefix" mathvariant="bold">(</mo><mi>ùêã</mi><mo mathvariant="bold">‚àò</mo><mi>ùêã</mi><mo stretchy="true" form="postfix" mathvariant="bold">)</mo></mrow><mn>ùüè</mn></mrow></mrow><annotation encoding="application/x-tex">
\mathrm{diag}(\mathbf\Sigma) = \mathbf{(L \circ L) 1} 
</annotation></semantics></math> Now suppose we have a desired vector of
length
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mi>J</mi></mrow><annotation encoding="application/x-tex">TJ</annotation></semantics></math>
for the constant marginal variance
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ùêØ</mi><annotation encoding="application/x-tex">\mathbf v</annotation></semantics></math>.
We can solve for the exogenous covariance that would result in that
marginal variance:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ùêÆ</mi><mo>=</mo><msup><mrow><mo stretchy="true" form="prefix" mathvariant="bold">(</mo><mi>ùêã</mi><mo mathvariant="bold">‚àò</mo><mi>ùêã</mi><mo stretchy="true" form="postfix" mathvariant="bold">)</mo></mrow><mrow><mo>‚àí</mo><mn>1</mn></mrow></msup><mi>ùêØ</mi></mrow><annotation encoding="application/x-tex">
\mathbf u = \mathbf{(L \circ L)}^{-1} \mathbf v
</annotation></semantics></math></p>
<p>and we can then rescale the exogenous covariance:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">d</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">g</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>ùêÜ</mi><mo>*</mo></msup><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>ùêÆ</mi></mrow><annotation encoding="application/x-tex">
\mathrm{diag}(\mathbf G^*) = \mathbf u
</annotation></semantics></math> and then using this rescaled exogenous
covariance when constructing the precision of the GMRF. We can see this
again using our first-order autoregressive example</p>
<div class="sourceCode" id="cb5"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># call dsem without estimating parameters</span></span>
<span><span class="va">out</span> <span class="op">=</span> <span class="fu"><a href="../reference/dsem.html">dsem</a></span><span class="op">(</span></span>
<span>  tsdata <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/ts.html" class="external-link">ts</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/data.frame.html" class="external-link">data.frame</a></span><span class="op">(</span> x <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep</a></span><span class="op">(</span><span class="fl">1</span>,<span class="fl">10</span><span class="op">)</span> <span class="op">)</span><span class="op">)</span>,</span>
<span>  sem <span class="op">=</span> <span class="va">dsem</span>,</span>
<span>  control <span class="op">=</span> <span class="fu"><a href="../reference/dsem_control.html">dsem_control</a></span><span class="op">(</span></span>
<span>    run_model <span class="op">=</span> <span class="cn">FALSE</span>, </span>
<span>    quiet <span class="op">=</span> <span class="cn">TRUE</span>, </span>
<span>    constant_variance <span class="op">=</span> <span class="st">"marginal"</span></span>
<span>  <span class="op">)</span></span>
<span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Extract covariance</span></span>
<span><span class="va">Sigma2</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/solve.html" class="external-link">solve</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">as.matrix</a></span><span class="op">(</span><span class="va">out</span><span class="op">$</span><span class="va">obj</span><span class="op">$</span><span class="fu">report</span><span class="op">(</span><span class="op">)</span><span class="op">$</span><span class="va">Q_kk</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/plot.html" class="external-link">plot</a></span><span class="op">(</span> x<span class="op">=</span><span class="fl">1</span><span class="op">:</span><span class="fl">10</span>, y <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/diag.html" class="external-link">diag</a></span><span class="op">(</span><span class="va">Sigma2</span><span class="op">)</span>, xlab<span class="op">=</span><span class="st">"time"</span>, </span>
<span>      ylab<span class="op">=</span><span class="st">"Marginal variance"</span>, type<span class="op">=</span><span class="st">"l"</span>, </span>
<span>      ylim <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">0</span>,<span class="fu"><a href="https://rdrr.io/r/base/Extremes.html" class="external-link">max</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/diag.html" class="external-link">diag</a></span><span class="op">(</span><span class="va">Sigma1</span><span class="op">)</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<p><img src="model-description_files/figure-html/unnamed-chunk-5-1.png" width="700"></p>
<p>This shows that the corrected (nonstationary) exogenous variance
results in a stationary marginal variance for the AR1 process. This
correction can be done in two different ways that are identical when the
exogenous covariance is diagonal (as it is in this simple example), but
differ when specifying some exogenous covariance. However, we do not
discuss this in detail here. Note that this calculating this correction
for a constant marginal variance requires the inverse of the squared
values of Leontief matrix (which is itself a matrix inverse). It
therefore is computationally expensive for large models containing
complicated dependencies.</p>
</div>
<div class="section level4">
<h4 id="reduced-rank-models">Reduced rank models<a class="anchor" aria-label="anchor" href="#reduced-rank-models"></a>
</h4>
<p>We note that some DSEM specifications will be reduced rank. This
arises for example when specifying a dynamic factor analysis, where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>J</mi><annotation encoding="application/x-tex">J</annotation></semantics></math>
variables are explained by
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo>&lt;</mo><mi>J</mi></mrow><annotation encoding="application/x-tex">F &lt; J</annotation></semantics></math>
factors that each follow a random walk:</p>
<div class="sourceCode" id="cb6"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#</span></span>
<span><span class="va">dsem</span> <span class="op">=</span> <span class="st">"</span></span>
<span><span class="st">  # Factor follows random walk with unit variance</span></span>
<span><span class="st">  F &lt;-&gt; F, 0, NA, 1</span></span>
<span><span class="st">  F -&gt; F, 1, NA, 1</span></span>
<span><span class="st">  # Loadings on two manifest variables</span></span>
<span><span class="st">  F -&gt; x, 0, b_x, 1</span></span>
<span><span class="st">  F -&gt; y, 0, b_y, 1</span></span>
<span><span class="st">  # No residual variance for manifest variables</span></span>
<span><span class="st">  x &lt;-&gt; x, 0, NA, 0</span></span>
<span><span class="st">  y &lt;-&gt; y, 0, NA, 0</span></span>
<span><span class="st">"</span></span>
<span><span class="va">data</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html" class="external-link">data.frame</a></span><span class="op">(</span> </span>
<span>  x <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/Normal.html" class="external-link">rnorm</a></span><span class="op">(</span><span class="fl">10</span><span class="op">)</span>,</span>
<span>  y <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/Normal.html" class="external-link">rnorm</a></span><span class="op">(</span><span class="fl">10</span><span class="op">)</span>,</span>
<span>  F <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep</a></span><span class="op">(</span><span class="cn">NA</span>,<span class="fl">10</span><span class="op">)</span></span>
<span><span class="op">)</span></span>
<span></span>
<span><span class="co"># call dsem without estimating parameters</span></span>
<span><span class="va">out</span> <span class="op">=</span> <span class="fu"><a href="../reference/dsem.html">dsem</a></span><span class="op">(</span></span>
<span>  tsdata <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/ts.html" class="external-link">ts</a></span><span class="op">(</span><span class="va">data</span><span class="op">)</span>,</span>
<span>  sem <span class="op">=</span> <span class="va">dsem</span>,</span>
<span>  family <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"normal"</span>,<span class="st">"normal"</span>,<span class="st">"fixed"</span><span class="op">)</span>,</span>
<span>  control <span class="op">=</span> <span class="fu"><a href="../reference/dsem_control.html">dsem_control</a></span><span class="op">(</span></span>
<span>    run_model <span class="op">=</span> <span class="cn">FALSE</span>, </span>
<span>    quiet <span class="op">=</span> <span class="cn">TRUE</span>,</span>
<span>    gmrf_parameterization <span class="op">=</span> <span class="st">"projection"</span></span>
<span>  <span class="op">)</span></span>
<span><span class="op">)</span></span></code></pre></div>
<p>We can extract the covariance and inspect the eigenvalues:</p>
<div class="sourceCode" id="cb7"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Extract covariance</span></span>
<span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://Matrix.R-forge.R-project.org" class="external-link">Matrix</a></span><span class="op">)</span></span>
<span><span class="va">IminusRho_kk</span> <span class="op">=</span> <span class="va">out</span><span class="op">$</span><span class="va">obj</span><span class="op">$</span><span class="fu">report</span><span class="op">(</span><span class="op">)</span><span class="op">$</span><span class="va">IminusRho_kk</span></span>
<span><span class="va">G_kk</span> <span class="op">=</span> <span class="va">out</span><span class="op">$</span><span class="va">obj</span><span class="op">$</span><span class="fu">report</span><span class="op">(</span><span class="op">)</span><span class="op">$</span><span class="va">Gamma_kk</span></span>
<span><span class="va">Q_kk</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/t.html" class="external-link">t</a></span><span class="op">(</span><span class="va">IminusRho_kk</span><span class="op">)</span> <span class="op"><a href="https://rdrr.io/r/base/matmult.html" class="external-link">%*%</a></span> <span class="fu"><a href="https://rdrr.io/r/base/t.html" class="external-link">t</a></span><span class="op">(</span><span class="va">G_kk</span><span class="op">)</span> <span class="op"><a href="https://rdrr.io/r/base/matmult.html" class="external-link">%*%</a></span> <span class="va">G_kk</span> <span class="op"><a href="https://rdrr.io/r/base/matmult.html" class="external-link">%*%</a></span> <span class="va">IminusRho_kk</span></span>
<span></span>
<span><span class="co"># Display eigenvalues</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/eigen.html" class="external-link">eigen</a></span><span class="op">(</span><span class="va">Q_kk</span><span class="op">)</span><span class="op">$</span><span class="va">values</span></span>
<span><span class="co">#&gt;  [1] 3.91114561 3.65247755 3.24697960 2.73068205 2.14946019 1.55495813</span></span>
<span><span class="co">#&gt;  [7] 1.00000000 0.53389626 0.19806226 0.02233835 0.00000000 0.00000000</span></span>
<span><span class="co">#&gt; [13] 0.00000000 0.00000000 0.00000000 0.00000000 0.00000000 0.00000000</span></span>
<span><span class="co">#&gt; [19] 0.00000000 0.00000000 0.00000000 0.00000000 0.00000000 0.00000000</span></span>
<span><span class="co">#&gt; [25] 0.00000000 0.00000000 0.00000000 0.00000000 0.00000000 0.00000000</span></span></code></pre></div>
<p>where this shows that the precision has a rank of 10 while being a
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>30</mn><mo>√ó</mo><mn>30</mn></mrow><annotation encoding="application/x-tex">30 \times 30</annotation></semantics></math>
matrix. We therefore cannot evaluate the probability density of state
matrix
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ùêó</mi><annotation encoding="application/x-tex">\mathbf X</annotation></semantics></math>
using this precision matrix (i.e., the log-determinant is not
defined).</p>
<p>To address this circumstance, we can switch to using
<code>gmrf_parameterization = "projection"</code>. This evaluates the
probability density of a set of innovations
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>ùêó</mi><mo>*</mo></msup><annotation encoding="application/x-tex">\mathbf X^*</annotation></semantics></math>
that follow a unit variance:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">v</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">c</mi></mrow><msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>ùêó</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>*</mo></msup><mo>‚àº</mo><mrow><mi mathvariant="normal">G</mi><mi mathvariant="normal">M</mi><mi mathvariant="normal">R</mi><mi mathvariant="normal">F</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mrow><mn>ùüé</mn><mo mathvariant="bold">,</mo><mi>ùêà</mi></mrow><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">
\mathrm{vec}(\mathbf X)^* \sim \mathrm{GMRF}(\mathbf{0, I})
</annotation></semantics></math> and then projects these full-rank
innovations to the reduced rank states:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">v</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">c</mi></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>ùêó</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msup><mrow><mo stretchy="true" form="prefix">(</mo><msub><mrow><mi>ùêà</mi><mo mathvariant="bold">‚àí</mo><mi>ùêè</mi></mrow><mrow><mi mathvariant="normal">j</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">t</mi></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mo>‚àí</mo><mn>1</mn></mrow></msup><msub><mi>ùêÜ</mi><mrow><mi mathvariant="normal">j</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">t</mi></mrow></msub><mrow><mi mathvariant="normal">v</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">c</mi></mrow><msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>ùêó</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>*</mo></msup></mrow><annotation encoding="application/x-tex">
\mathrm{vec}(\mathbf X) = (\mathbf{I - P}_{\mathrm{joint}})^{-1} \mathbf G_{\mathrm{joint}} \mathrm{vec}(\mathbf X)^*
</annotation></semantics></math></p>
<p>This parameterization allows us to fit DSEM using a rank-deficient
structural model.</p>
</div>
</div>
  </main><aside class="col-md-3"><nav id="toc" aria-label="Table of contents"><h2>On this page</h2>
    </nav></aside>
</div>



    <footer><div class="pkgdown-footer-left">
  <p>Developed by James Thorson.</p>
</div>

<div class="pkgdown-footer-right">
  <p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.1.1.</p>
</div>

    </footer>
</div>





  </body>
</html>
