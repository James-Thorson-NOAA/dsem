---
title: "Dynamic factor analysis"
author: "James Thorson"
output: rmarkdown::html_vignette
#output: rmarkdown::pdf_document
vignette: >
  %\VignetteIndexEntry{Dynamic factor analysis}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE, warning=FALSE, message=FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
# Install locally
#  devtools::install_local( R'(C:\Users\James.Thorson\Desktop\Git\dsem)', force=TRUE )
# Build
#  setwd(R'(C:\Users\James.Thorson\Desktop\Git\dsem)'); devtools::build_rmd("vignettes/dynamic_factor_analysis.Rmd")
```

## Dynamic factor analysis

`dsem` is an R package for fitting dynamic structural equation models (DSEMs) with a simple user-interface and generic specification of simultaneous and lagged effects in a non-recursive structure. Here, we highlight how DSEM can be used to implement dynamic factor analysis (DFA).  We specifically replicate analysis using the Multivariate Autoregressive State-Space (MARSS) package, using data that are provided as an example in the MARSS package.

```{r setup, echo=TRUE, message=FALSE}
library(dsem)
library(MARSS)
library(ggplot2)
data( harborSealWA, package="MARSS")

# Define helper function
grab = \(x,name) x[which(names(x)==name)] 
n_factors = 3 # n_factors >= 3 doesn't seem to work using DSEM
```


## Using MARSS

We first illustrate a DFA model using three factors, fitted using MARSS:

```{r, echo=TRUE, message=FALSE, fig.width=7, fig.height=7}
# Load data
dat <- t(harborSealWA[,c("SJI","EBays","SJF","PSnd","HC")])

# DFA with 3 states; used BFGS because it fits much faster for this model
fit_MARSS <- MARSS( dat, 
                    model = list(m=n_factors),
                    form="dfa", 
                    method="BFGS",
                    silent = TRUE )

# Plots states using all data
plot(fit_MARSS, plot.type="xtT")

# Plot expectation for data using all data
plot(fit_MARSS, plot.type="fitted.ytT")
```

## Full-rank covariance using DSEM 

In DSEM syntax, we can first fit a saturated (full-covariance) model using the argument `covs`:

```{r, echo=TRUE, message=FALSE, fig.width=7, fig.height=7}
# Add factors to data
tsdata = ts( cbind(harborSealWA[,c("SJI","EBays","SJF","PSnd","HC")]), start=1978)

# Scale and center (matches with MARSS does when fitting a DFA)
tsdata = scale( tsdata, center=TRUE, scale=TRUE )

# Define SEM
sem = "
  # Random-walk process for variables 
  SJF -> SJF, 1, NA, 1
  SJI -> SJI, 1, NA, 1
  EBays -> EBays, 1, NA, 1
  PSnd -> PSnd, 1, NA, 1
  HC -> HC, 1, NA, 1
"

# Initial fit
mydsem0 = dsem( tsdata = tsdata,
               covs = c("SJF, SJI, EBays, PSnd, HC"),
               sem = sem,
               family = rep("normal", 5),
               control = dsem_control( quiet = TRUE,
                                       run_model = FALSE ) )   

# fix all measurement errors at diagonal and equal
map = mydsem0$tmb_inputs$map
map$lnsigma_j = factor( rep(1,ncol(tsdata)) )

#
mydsem_full = dsem( tsdata = tsdata,
               covs = c("SJF, SJI, EBays, PSnd, HC"),
               sem = sem,
               family = rep("normal", 5),
               control = dsem_control( quiet = TRUE,
                                       map = map ) )
```

We can then define a custom function to plot states:

```{r, echo=TRUE, message=FALSE, fig.width=7, fig.height=7}
plot_states = function( out,
                        vars=1:ncol(out$tmb_inputs$data$y_tj) ){
  # 
  xhat_tj = as.list(out$sdrep,report=TRUE,what="Estimate")$z_tj[,vars,drop=FALSE]
  xse_tj = as.list(out$sdrep,report=TRUE,what="Std. Error")$z_tj[,vars,drop=FALSE]

  # 
  longform = expand.grid( Year=time(tsdata), Var=colnames(tsdata)[vars] )
  longform$est = as.vector(xhat_tj)
  longform$se = as.vector(xse_tj)
  longform$upper = longform$est + 1.96*longform$se
  longform$lower = longform$est - 1.96*longform$se
  longform$data = as.vector(tsdata[,vars,drop=FALSE])
  
  # 
  ggplot(data=longform) +  #, aes(x=interaction(var,eq), y=Estimate, color=method)) +
    geom_line( aes(x=Year,y=est) ) +
    geom_point( aes(x=Year,y=data), color="blue", na.rm=TRUE ) +
    geom_ribbon( aes(ymax=as.numeric(upper),ymin=as.numeric(lower), x=Year), color="grey", alpha=0.2 ) + 
    facet_wrap( facets=vars(Var), scales="free", ncol=2 )
}
plot_states( mydsem_full )
```

These estimated states follow the data more closely and have smaller estimated confidence intervals. Presumably this occurs because we are using a full-rank covariance so far.

## Reduced-rank factor model with measurement errors

Next, we can specify three factors factors while eliminating additional process error and estimating measurement errors.  This requires us to switch to `gmrf_parameterization = "projection"`, so that we can fit a rank-deficient Gaussian Markov random field:

```{r, echo=TRUE, message=FALSE, fig.width=7, fig.height=7}
# Add factors to data
tsdata = harborSealWA[,c("SJI","EBays","SJF","PSnd","HC")]
newcols = array( NA,
                 dim = c(nrow(tsdata),n_factors),
                 dimnames = list(NULL,paste0("F",seq_len(n_factors))) )
tsdata = ts( cbind(tsdata, newcols), start=1978)

# Scale and center (matches with MARSS does when fitting a DFA)
tsdata = scale( tsdata, center=TRUE, scale=TRUE )

#
#sem = "
#  # Fixed SD=1 for factors
#  F1 <-> F1, 0, NA, 1
#  F2 <-> F2, 0, NA, 1
#  F3 <-> F3, 0, NA, 1
#  # Fixed random-walk for factors
#  F1 -> F1, 1, NA, 1
#  F2 -> F2, 1, NA, 1
#  F3 -> F3, 1, NA, 1
#  # Loadings
#  F1 -> SJI, 0, f11
#  F1 -> EBays, 0, f12
#  F1 -> SJF, 0, f13
#  F1 -> PSnd, 0, f14
#  F1 -> HC, 0, f15
#  F2 -> EBays, 0, f22
#  F2 -> SJF, 0, f23
#  F2 -> PSnd, 0, f24
#  F2 -> HC, 0, f25
#  F3 -> SJF, 0, f33
#  F3 -> PSnd, 0, f34
#  F3 -> HC, 0, f35
#  # Fix SD=0 for additional process error variance
#  SJF <-> SJF, 0, NA, 0
#  SJI <-> SJI, 0, NA, 0
#  EBays <-> EBays, 0, NA, 0
#  PSnd <-> PSnd, 0, NA, 0
#  HC <-> HC, 0, NA, 0
#"
sem = make_dfa( variables = c("SJI","EBays","SJF","PSnd","HC"),
                n_factors = 3 )

# Initial fit
mydsem0 = dsem( tsdata = tsdata,
               sem = sem,
               family = c( rep("normal",5), rep("fixed",n_factors) ),
               estimate_delta0 = TRUE,
               control = dsem_control( quiet = TRUE,
                                       run_model = FALSE,
                                       gmrf_parameterization = "projection" ) )

# fix all measurement errors at diagonal and equal
map = mydsem0$tmb_inputs$map
map$lnsigma_j = factor( rep(1,ncol(tsdata)) )

# Fix factors to have initial value, and variables to not
map$delta0_j = factor( c(rep(NA,ncol(harborSealWA)-1), 1:n_factors) )

# Fix variables to have no stationary mean except what's predicted by initial value
map$mu_j = factor( rep(NA,ncol(tsdata)) )

# profile "delta0_j" to match MARSS (which treats initial condition as unpenalized random effect)
mydfa = dsem( tsdata = tsdata,
               sem = sem,
               family = c( rep("normal",5), rep("fixed",n_factors) ),
               estimate_delta0 = TRUE,
               control = dsem_control( quiet = TRUE,
                                       map = map,
                                       use_REML = TRUE,
                                       profile = "delta0_j",
                                       gmrf_parameterization = "projection" ) )

# Plot estimated factors
plot_states( mydfa, vars=6:8 )

# Plot estimated variables
plot_states( mydfa, vars=1:5 )
```

This results in similar (but not identical) factor values using MARSS and DSEM.  In particular, DSEM has higher variance in early years.

We can also compare the two in terms of estimated loadings:

```{r, echo=TRUE, message=FALSE, fig.width=7, fig.height=7}
Table = cbind( "MARSS" = as.vector(fit_MARSS$par$Z),
       "DSEM_measurement_error" = grab(mydfa$opt$par,"beta_z") )
rownames(Table) = names(fit_MARSS$coef)[1:nrow(Table)]
knitr::kable( Table, digits=3)       
```

The estimating loadings are similar (but not identical) to those resulting from MARSS, except with label switching (where some factors and loadings can be multiplied by -1 with no change in teh model):

