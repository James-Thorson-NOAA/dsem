[{"path":"/articles/vignette.html","id":"comparison-with-dynamic-linear-models","dir":"Articles","previous_headings":"","what":"Comparison with dynamic linear models","title":"Demonstration of selected features","text":"first demonstrate dsem gives identical results dynlm well-known econometric model, Klein-1 model.    Results show packages provide (almost) identical estimates standard errors. can also compare results using Laplace approximation obtained via numerical integration random effects using MCMC. example, MCMC results somewhat higher estimates exogenous variance parameters (presumably follow chi-squared distribution positive skewness), otherwise two produce similar estimates.","code":"data(KleinI, package=\"AER\") TS = ts(data.frame(KleinI, \"time\"=time(KleinI) - 1931))  # dynlm fm_cons <- dynlm(consumption ~ cprofits + L(cprofits) + I(pwage + gwage), data = TS) fm_inv <- dynlm(invest ~ cprofits + L(cprofits) + capital, data = TS)                 # fm_pwage <- dynlm(pwage ~ gnp + L(gnp) + time, data = TS)  # dsem sem = \"   # Link, lag, param_name   cprofits -> consumption, 0, a1   cprofits -> consumption, 1, a2   pwage -> consumption, 0, a3   gwage -> consumption, 0, a3    cprofits -> invest, 0, b1   cprofits -> invest, 1, b2   capital -> invest, 0, b3    gnp -> pwage, 0, c2   gnp -> pwage, 1, c3   time -> pwage, 0, c1 \" tsdata = TS[,c(\"time\",\"gnp\",\"pwage\",\"cprofits\",'consumption',                \"gwage\",\"invest\",\"capital\")] fit = dsem( sem=sem,             tsdata = tsdata,             estimate_delta0 = TRUE,             control = dsem_control(               quiet = TRUE,               newton_loops = 0) ) #> 1 regions found. #> Using 1 threads #> 1 regions found. #> Using 1 threads  # Compile m1 = rbind( summary(fm_cons)$coef[-1,],             summary(fm_inv)$coef[-1,],             summary(fm_pwage)$coef[-1,] )[,1:2] m2 = summary(fit$sdrep)[1:9,] m = rbind(   data.frame(\"var\"=rownames(m1),m1,\"method\"=\"OLS\",\"eq\"=rep(c(\"C\",\"I\",\"Wp\"),each=3)),   data.frame(\"var\"=rownames(m1),m2,\"method\"=\"GMRF\",\"eq\"=rep(c(\"C\",\"I\",\"Wp\"),each=3)) ) m = cbind(m, \"lower\"=m$Estimate-m$Std..Error, \"upper\"=m$Estimate+m$Std..Error )  # ggplot estimates  longform = melt( as.data.frame(KleinI) )   longform$year = rep( time(KleinI), 9 ) p1 = ggplot( data=longform, aes(x=year, y=value) ) +   facet_grid( rows=vars(variable), scales=\"free\" ) +   geom_line( )  p2 = ggplot(data=m, aes(x=interaction(var,eq), y=Estimate, color=method)) +   geom_point( position=position_dodge(0.9) ) +   geom_errorbar( aes(ymax=as.numeric(upper),ymin=as.numeric(lower)),                  width=0.25, position=position_dodge(0.9))  #  p3 = plot( as_fitted_DAG(fit) ) +      expand_limits(x = c(-0.2,1) ) p4 = plot( as_fitted_DAG(fit, lag=1), text_size=4 ) +      expand_limits(x = c(-0.2,1), y = c(-0.2,0) )  p1 p2 grid.arrange( arrangeGrob(p3, p4, nrow=2) ) library(tmbstan)  # MCMC for both fixed and random effects mcmc = tmbstan( fit$obj, init=\"last.par.best\" ) summary_mcmc = summary(mcmc) # long-form data frame m1 = summary_mcmc$summary[1:17,c('mean','sd')] rownames(m1) = paste0( \"b\", seq_len(nrow(m1)) ) m2 = summary(fit$sdrep)[1:17,c('Estimate','Std. Error')] m = rbind(   data.frame('mean'=m1[,1], 'sd'=m1[,2], 'par'=rownames(m1), \"method\"=\"MCMC\"),   data.frame('mean'=m2[,1], 'sd'=m2[,2], 'par'=rownames(m1), \"method\"=\"LA\") ) m$lower = m$mean - m$sd m$upper = m$mean + m$sd  # plot ggplot(data=m, aes(x=par, y=mean, col=method)) +   geom_point( position=position_dodge(0.9) ) +   geom_errorbar( aes(ymax=as.numeric(upper),ymin=as.numeric(lower)),                  width=0.25, position=position_dodge(0.9))  #"},{"path":"/articles/vignette.html","id":"comparison-with-vector-autoregressive-models","dir":"Articles","previous_headings":"","what":"Comparison with vector autoregressive models","title":"Demonstration of selected features","text":"next demonstrate dsem gives similar results vector autoregressive (VAR) model. , analyze population abundance wolf moose populations Isle Royale 1959 2019, downloaded website (Vucetich, JA Peterson RO. 2012. population biology Isle Royale wolves moose: overview. URL: www.isleroyalewolf.org). dataset previously analyzed Chapter 14 User Manual R-package MARSS (Holmes, E. E., M. D. Scheuerell, E. J. Ward (2023) Analysis multivariate time-series using MARSS package. Version 3.11.8. NOAA Fisheries, Northwest Fisheries Science Center, 2725 Montlake Blvd E., Seattle, WA 98112, DOI: 10.5281/zenodo.5781847). , compare fits using dsem dynlm, well vector autoregressive model package vars, finally MARSS.  Results show dsem can estimate parameters vector autoregressive model (VAM), exactly matches results vars, using dynlm, using MARSS.","code":"data(isle_royale) data = ts( log(isle_royale[,2:3]), start=1959)  sem = \"   # Link, lag, param_name   wolves -> wolves, 1, arW   moose -> wolves, 1, MtoW   wolves -> moose, 1, WtoM   moose -> moose, 1, arM \" # initial first without delta0 (to improve starting values) fit0 = dsem( sem = sem,              tsdata = data,              estimate_delta0 = FALSE,              control = dsem_control(                quiet = TRUE,                getsd = FALSE) ) #> Warning in nlminb(start = out$opt$par, objective = obj$fn, gradient = obj$gr, : #> NA/NaN function evaluation # Refit with delta0 fit = dsem( sem = sem,             tsdata = data,             estimate_delta0 = TRUE,             control = dsem_control( quiet=TRUE,                                     parameters = fit0$obj$env$parList()) )  # dynlm fm_wolf = dynlm( wolves ~ 1 + L(wolves) + L(moose), data=data )   # fm_moose = dynlm( moose ~ 1 + L(wolves) + L(moose), data=data )   #  # MARSS library(MARSS) z.royale.dat <- t(scale(data.frame(data),center=TRUE,scale=FALSE)) royale.model.1 <- list(   Z = \"identity\",   B = \"unconstrained\",   Q = \"diagonal and unequal\",   R = \"zero\",   U = \"zero\" ) kem.1 <- MARSS(z.royale.dat, model = royale.model.1) #> Success! algorithm run for 15 iterations. abstol and log-log tests passed. #> Alert: conv.test.slope.tol is 0.5. #> Test with smaller values (<0.1) to ensure convergence. #>  #> MARSS fit is #> Estimation method: kem  #> Convergence test: conv.test.slope.tol = 0.5, abstol = 0.001 #> Algorithm ran 15 (=minit) iterations and convergence was reached.  #> Log-likelihood: -3.21765  #> AIC: 22.4353   AICc: 23.70964    #>   #>                       Estimate #> B.(1,1)                 0.8669 #> B.(2,1)                -0.1240 #> B.(1,2)                 0.1417 #> B.(2,2)                 0.8176 #> Q.(X.wolves,X.wolves)   0.1341 #> Q.(X.moose,X.moose)     0.0284 #> x0.X.wolves             0.2324 #> x0.X.moose             -0.6476 #> Initial states (x0) defined at t=0 #>  #> Standard errors have not been calculated.  #> Use MARSSparamCIs to compute CIs and bias estimates. SE <- MARSSparamCIs( kem.1 )  # Using VAR package library(vars) var = VAR( data, type=\"const\" )  ### Compile m1 = rbind( summary(fm_wolf)$coef[-1,], summary(fm_moose)$coef[-1,] )[,1:2] m2 = summary(fit$sdrep)[1:4,] #m2 = cbind( \"Estimate\"=fit$opt$par, \"Std. Error\"=fit$sdrep$par.fixed )[1:4,] m3 = cbind( SE$parMean[c(1,3,2,4)], SE$par.se$B[c(1,3,2,4)] ) colnames(m3) = colnames(m2) m4 = rbind( summary(var$varresult$wolves)$coef[-3,], summary(var$varresult$moose)$coef[-3,] )[,1:2]  # Bundle m = rbind(   data.frame(\"var\"=rownames(m1), m1, \"method\"=\"dynlm\", \"eq\"=rep(c(\"Wolf\",\"Moose\"),each=2)),   data.frame(\"var\"=rownames(m1), m2, \"method\"=\"dsem\", \"eq\"=rep(c(\"Wolf\",\"Moose\"),each=2)),   data.frame(\"var\"=rownames(m1), m3, \"method\"=\"MARSS\", \"eq\"=rep(c(\"Wolf\",\"Moose\"),each=2)),   data.frame(\"var\"=rownames(m1), m4, \"method\"=\"vars\", \"eq\"=rep(c(\"Wolf\",\"Moose\"),each=2)) ) #knitr::kable( m1, digits=3) #knitr::kable( m2, digits=3)  m = cbind(m, \"lower\"=m$Estimate-m$Std..Error, \"upper\"=m$Estimate+m$Std..Error )  # ggplot estimates ... interaction(x,y) causes an error sometimes library(ggplot2) library(ggpubr) library(ggraph) longform = reshape( isle_royale, idvar = \"year\", direction=\"long\", varying=list(2:3), v.names=\"abundance\", timevar=\"species\", times=c(\"wolves\",\"moose\") ) p1 = ggplot( data=longform, aes(x=year, y=abundance) ) +   facet_grid( rows=vars(species), scales=\"free\" ) +   geom_point( )  p2 = ggplot(data=m, aes(x=interaction(var,eq), y=Estimate, color=method)) +   geom_point( position=position_dodge(0.9) ) +   geom_errorbar( aes(ymax=as.numeric(upper),ymin=as.numeric(lower)),                  width=0.25, position=position_dodge(0.9))  # p3 = plot( as_fitted_DAG(fit, lag=1), rotation=0 ) +      geom_edge_loop( aes( label=round(weight,2), direction=0)) + #arrow=arrow(), , angle_calc=\"along\", label_dodge=grid::unit(10,\"points\") )      expand_limits(x = c(-0.1,0) )  ggarrange( p1, p2, p3,            labels = c(\"Time-series data\", \"Estimated effects\", \"Fitted path digram\"),            ncol = 1, nrow = 3)"},{"path":"/articles/vignette.html","id":"multi-causal-ecosystem-synthesis","dir":"Articles","previous_headings":"","what":"Multi-causal ecosystem synthesis","title":"Demonstration of selected features","text":"next replicate analysis involving climate, forage fishes, stomach contents, recruitment predatory fish.   results discussed paper describing dsem.","code":"data(bering_sea) Z = ts( bering_sea ) family = rep('fixed', ncol(bering_sea))  # Specify model sem = \"   # Link, lag, param_name   log_seaice -> log_CP, 0, seaice_to_CP   log_CP -> log_Cfall, 0, CP_to_Cfall   log_CP -> log_Esummer, 0, CP_to_E   log_PercentEuph -> log_RperS, 0, Seuph_to_RperS   log_PercentCop -> log_RperS, 0, Scop_to_RperS   log_Esummer -> log_PercentEuph, 0, Esummer_to_Suph   log_Cfall -> log_PercentCop, 0, Cfall_to_Scop   log_SSB -> log_RperS, 0, SSB_to_RperS    log_seaice -> log_seaice, 1, AR1, 0.001   log_CP -> log_CP, 1,  AR2, 0.001   log_Cspring -> log_Cspring, 1, AR3, 0.001   log_Cfall -> log_Cfall, 1, AR4, 0.001   log_Esummer -> log_Esummer, 1, AR5, 0.001   log_SSB -> log_SSB, 1, AR6, 0.001   log_RperS ->  log_RperS, 1, AR7, 0.001   log_PercentEuph -> log_PercentEuph, 1, AR8, 0.001   log_PercentCop -> log_PercentCop, 1, AR9, 0.001 \"  # Fit fit = dsem( sem = sem,             tsdata = Z,             family = family,             control = dsem_control(use_REML=FALSE, quiet=TRUE) ) ParHat = fit$obj$env$parList() # summary( fit ) # Timeseries plot oldpar <- par(no.readonly = TRUE) par( mfcol=c(3,3), mar=c(2,2,2,0), mgp=c(2,0.5,0), tck=-0.02 ) for(i in 1:ncol(bering_sea)){   tmp = bering_sea[,i,drop=FALSE]   tmp = cbind( tmp, \"PSEM\"=ParHat$x_tj[,i] )   SD = as.list(fit$sdrep,what=\"Std.\")$x_tj[,i]   tmp = cbind( tmp, outer(tmp[,2],c(1,1)) +                outer(ifelse(is.na(SD),0,SD),c(-1,1)) )   #   plot( x=rownames(bering_sea), y=tmp[,1], ylim=range(tmp,na.rm=TRUE),         type=\"p\", main=colnames(bering_sea)[i], pch=20, cex=2 )   lines( x=rownames(bering_sea), y=tmp[,2], type=\"l\", lwd=2,          col=\"blue\", lty=\"solid\" )   polygon( x=c(rownames(bering_sea),rev(rownames(bering_sea))),            y=c(tmp[,3],rev(tmp[,4])), col=rgb(0,0,1,0.2), border=NA ) } par(oldpar) # library(phylopath) library(ggplot2) library(ggpubr) library(reshape) library(gridExtra) longform = melt( bering_sea )   longform$year = rep( 1963:2023, ncol(bering_sea) ) p0 = ggplot( data=longform, aes(x=year, y=value) ) +   facet_grid( rows=vars(variable), scales=\"free\" ) +   geom_point( )  p1 = plot( (as_fitted_DAG(fit)), edge.width=1, type=\"width\",            text_size=4, show.legend=FALSE,            arrow = grid::arrow(type='closed', 18, grid::unit(10,'points')) ) +      scale_x_continuous(expand = c(0.4, 0.1)) p1$layers[[1]]$mapping$edge_width = 1 p2 = plot( (as_fitted_DAG(fit, what=\"p_value\")), edge.width=1, type=\"width\",            text_size=4, show.legend=FALSE, colors=c('black', 'black'),            arrow = grid::arrow(type='closed', 18, grid::unit(10,'points')) ) +      scale_x_continuous(expand = c(0.4, 0.1)) p2$layers[[1]]$mapping$edge_width = 0.5  #grid.arrange( arrangeGrob( p0+ggtitle(\"timeseries\"), #              arrangeGrob( p1+ggtitle(\"Estimated path diagram\"), #                           p2+ggtitle(\"Estimated p-values\"), nrow=2), ncol=2 ) ) ggarrange(p1, p2, labels = c(\"Simultaneous effects\", \"Two-sided p-value\"),                     ncol = 1, nrow = 2)"},{"path":"/articles/vignette.html","id":"site-replicated-trophic-cascade","dir":"Articles","previous_headings":"","what":"Site-replicated trophic cascade","title":"Demonstration of selected features","text":"Finally, replicate analysis involving trophic cascade involving sea stars predators, sea urchin consumers, kelp producers.  , results discussed paper describing dsem.","code":"data(sea_otter) Z = ts( sea_otter[,-1] )  # Specify model sem = \"   Pycno_CANNERY_DC -> log_Urchins_CANNERY_DC, 0, x2   log_Urchins_CANNERY_DC -> log_Kelp_CANNERY_DC, 0, x3   log_Otter_Count_CANNERY_DC -> log_Kelp_CANNERY_DC, 0, x4    Pycno_CANNERY_UC -> log_Urchins_CANNERY_UC, 0, x2   log_Urchins_CANNERY_UC -> log_Kelp_CANNERY_UC, 0, x3   log_Otter_Count_CANNERY_UC -> log_Kelp_CANNERY_UC, 0, x4    Pycno_HOPKINS_DC -> log_Urchins_HOPKINS_DC, 0, x2   log_Urchins_HOPKINS_DC -> log_Kelp_HOPKINS_DC, 0, x3   log_Otter_Count_HOPKINS_DC -> log_Kelp_HOPKINS_DC, 0, x4    Pycno_HOPKINS_UC -> log_Urchins_HOPKINS_UC, 0, x2   log_Urchins_HOPKINS_UC -> log_Kelp_HOPKINS_UC, 0, x3   log_Otter_Count_HOPKINS_UC -> log_Kelp_HOPKINS_UC, 0, x4    Pycno_LOVERS_DC -> log_Urchins_LOVERS_DC, 0, x2   log_Urchins_LOVERS_DC -> log_Kelp_LOVERS_DC, 0, x3   log_Otter_Count_LOVERS_DC -> log_Kelp_LOVERS_DC, 0, x4    Pycno_LOVERS_UC -> log_Urchins_LOVERS_UC, 0, x2   log_Urchins_LOVERS_UC -> log_Kelp_LOVERS_UC, 0, x3   log_Otter_Count_LOVERS_UC -> log_Kelp_LOVERS_UC, 0, x4    Pycno_MACABEE_DC -> log_Urchins_MACABEE_DC, 0, x2   log_Urchins_MACABEE_DC -> log_Kelp_MACABEE_DC, 0, x3   log_Otter_Count_MACABEE_DC -> log_Kelp_MACABEE_DC, 0, x4    Pycno_MACABEE_UC -> log_Urchins_MACABEE_UC, 0, x2   log_Urchins_MACABEE_UC -> log_Kelp_MACABEE_UC, 0, x3   log_Otter_Count_MACABEE_UC -> log_Kelp_MACABEE_UC, 0, x4    Pycno_OTTER_PT_DC -> log_Urchins_OTTER_PT_DC, 0, x2   log_Urchins_OTTER_PT_DC -> log_Kelp_OTTER_PT_DC, 0, x3   log_Otter_Count_OTTER_PT_DC -> log_Kelp_OTTER_PT_DC, 0, x4    Pycno_OTTER_PT_UC -> log_Urchins_OTTER_PT_UC, 0, x2   log_Urchins_OTTER_PT_UC -> log_Kelp_OTTER_PT_UC, 0, x3   log_Otter_Count_OTTER_PT_UC -> log_Kelp_OTTER_PT_UC, 0, x4    Pycno_PINOS_CEN -> log_Urchins_PINOS_CEN, 0, x2   log_Urchins_PINOS_CEN -> log_Kelp_PINOS_CEN, 0, x3   log_Otter_Count_PINOS_CEN -> log_Kelp_PINOS_CEN, 0, x4    Pycno_SIREN_CEN -> log_Urchins_SIREN_CEN, 0, x2   log_Urchins_SIREN_CEN -> log_Kelp_SIREN_CEN, 0, x3   log_Otter_Count_SIREN_CEN -> log_Kelp_SIREN_CEN, 0, x4    # AR1   Pycno_CANNERY_DC -> Pycno_CANNERY_DC, 1, ar1   log_Urchins_CANNERY_DC -> log_Urchins_CANNERY_DC, 1, ar2   log_Otter_Count_CANNERY_DC -> log_Otter_Count_CANNERY_DC, 1, ar3   log_Kelp_CANNERY_DC -> log_Kelp_CANNERY_DC, 1, ar4    Pycno_CANNERY_UC -> Pycno_CANNERY_UC, 1, ar1   log_Urchins_CANNERY_UC -> log_Urchins_CANNERY_UC, 1, ar2   log_Otter_Count_CANNERY_UC -> log_Otter_Count_CANNERY_UC, 1, ar3   log_Kelp_CANNERY_UC -> log_Kelp_CANNERY_UC, 1, ar4    Pycno_HOPKINS_DC -> Pycno_HOPKINS_DC, 1, ar1   log_Urchins_HOPKINS_DC -> log_Urchins_HOPKINS_DC, 1, ar2   log_Otter_Count_HOPKINS_DC -> log_Otter_Count_HOPKINS_DC, 1, ar3   log_Kelp_HOPKINS_DC -> log_Kelp_HOPKINS_DC, 1, ar4    Pycno_HOPKINS_UC -> Pycno_HOPKINS_UC, 1, ar1   log_Urchins_HOPKINS_UC -> log_Urchins_HOPKINS_UC, 1, ar2   log_Otter_Count_HOPKINS_UC -> log_Otter_Count_HOPKINS_UC, 1, ar3   log_Kelp_HOPKINS_UC -> log_Kelp_HOPKINS_UC, 1, ar4    Pycno_LOVERS_DC -> Pycno_LOVERS_DC, 1, ar1   log_Urchins_LOVERS_DC -> log_Urchins_LOVERS_DC, 1, ar2   log_Otter_Count_LOVERS_DC -> log_Otter_Count_LOVERS_DC, 1, ar3   log_Kelp_LOVERS_DC -> log_Kelp_LOVERS_DC, 1, ar4    Pycno_LOVERS_UC -> Pycno_LOVERS_UC, 1, ar1   log_Urchins_LOVERS_UC -> log_Urchins_LOVERS_UC, 1, ar2   log_Otter_Count_LOVERS_UC -> log_Otter_Count_LOVERS_UC, 1, ar3   log_Kelp_LOVERS_UC -> log_Kelp_LOVERS_UC, 1, ar4    Pycno_MACABEE_DC -> Pycno_MACABEE_DC, 1, ar1   log_Urchins_MACABEE_DC -> log_Urchins_MACABEE_DC, 1, ar2   log_Otter_Count_MACABEE_DC -> log_Otter_Count_MACABEE_DC, 1, ar3   log_Kelp_MACABEE_DC -> log_Kelp_MACABEE_DC, 1, ar4    Pycno_MACABEE_UC -> Pycno_MACABEE_UC, 1, ar1   log_Urchins_MACABEE_UC -> log_Urchins_MACABEE_UC, 1, ar2   log_Otter_Count_MACABEE_UC -> log_Otter_Count_MACABEE_UC, 1, ar3   log_Kelp_MACABEE_UC -> log_Kelp_MACABEE_UC, 1, ar4    Pycno_OTTER_PT_DC -> Pycno_OTTER_PT_DC, 1, ar1   log_Urchins_OTTER_PT_DC -> log_Urchins_OTTER_PT_DC, 1, ar2   log_Otter_Count_OTTER_PT_DC -> log_Otter_Count_OTTER_PT_DC, 1, ar3   log_Kelp_OTTER_PT_DC -> log_Kelp_OTTER_PT_DC, 1, ar4    Pycno_OTTER_PT_UC -> Pycno_OTTER_PT_UC, 1, ar1   log_Urchins_OTTER_PT_UC -> log_Urchins_OTTER_PT_UC, 1, ar2   log_Otter_Count_OTTER_PT_UC -> log_Otter_Count_OTTER_PT_UC, 1, ar3   log_Kelp_OTTER_PT_UC -> log_Kelp_OTTER_PT_UC, 1, ar4    Pycno_PINOS_CEN -> Pycno_PINOS_CEN, 1, ar1   log_Urchins_PINOS_CEN -> log_Urchins_PINOS_CEN, 1, ar2   log_Otter_Count_PINOS_CEN -> log_Otter_Count_PINOS_CEN, 1, ar3   log_Kelp_PINOS_CEN -> log_Kelp_PINOS_CEN, 1, ar4    Pycno_SIREN_CEN -> Pycno_SIREN_CEN, 1, ar1   log_Urchins_SIREN_CEN -> log_Urchins_SIREN_CEN, 1, ar2   log_Otter_Count_SIREN_CEN -> log_Otter_Count_SIREN_CEN, 1, ar3   log_Kelp_SIREN_CEN -> log_Kelp_SIREN_CEN, 1, ar4 \"  # Fit model fit = dsem( sem = sem,             tsdata = Z,             control = dsem_control(use_REML=FALSE, quiet=TRUE) ) # summary( fit )  # library(phylopath) library(ggplot2) library(ggpubr) get_part = function(x){   vars = c(\"log_Kelp\",\"log_Otter\",\"log_Urchin\",\"Pycno\")   index = sapply( vars, FUN=\\(y) grep(y,rownames(x$coef))[1] )   x$coef = x$coef[index,index]   dimnames(x$coef) = list( vars, vars )   return(x) } p1 = plot( get_part(as_fitted_DAG(fit)), type=\"width\", show.legend=FALSE) p1$layers[[1]]$mapping$edge_width = 0.5 p2 = plot( get_part(as_fitted_DAG(fit, what=\"p_value\" )), type=\"width\",            show.legend=FALSE, colors=c('black', 'black')) p2$layers[[1]]$mapping$edge_width = 0.1  longform = melt( sea_otter[,-1], as.is=TRUE ) #> Warning in type.convert.default(X[[i]], ...): 'as.is' should be specified by #> the caller; using TRUE longform$X1 = 1999:2019[longform$X1] #> Warning in 1999:2019[longform$X1]: numerical expression has 1008 elements: only #> the first used longform$Site = gsub( \"log_Kelp_\", \"\",                 gsub( \"log_Urchins_\", \"\",                 gsub( \"Pycno_\", \"\",                 gsub( \"log_Otter_Count_\", \"\", longform$X2)))) longform$Species = sapply( seq_len(nrow(longform)), FUN=\\(i)gsub(longform$Site[i],\"\",longform$X2[i]) ) p3 = ggplot( data=longform, aes(x=X1, y=value, col=Species) ) +   facet_grid( rows=vars(Site), scales=\"free\" ) +   geom_line( )  ggarrange(p1 + scale_x_continuous(expand = c(0.3, 0)),                     p2 + scale_x_continuous(expand = c(0.3, 0)),                     labels = c(\"Simultaneous effects\", \"Two-sided p-value\"),                     ncol = 1, nrow = 2)"},{"path":"/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"James Thorson. Author, maintainer.","code":""},{"path":"/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Thorson, J. T., Andrews, . G., Essington, T., & Large, S. (press). Dynamic structural equation models synthesize ecosystem dynamics constrained ecological mechanisms. Methods Ecology Evolution.","code":"@Article{,   title = {Dynamic structural equation models synthesize ecosystem dynamics constrained by ecological mechanisms},   journal = {Methods in Ecology and Evolution},   year = {2024},   author = {J. T. Thorson and A. G. Andrews and T. Essington and S. Large}, }"},{"path":"/index.html","id":"dynamic-structural-equation-models","dir":"","previous_headings":"","what":"Dynamic structural equation models","title":"Fit Dynamic Structural Equation Models","text":"Package dsem fits dynamic structural equation models, includes nested submodels: structural equation models vector autoregressive models dynamic factor analysis state-space autoregressive integrated moving average (ARIMA) models model several advantages: estimates direct, indirect, total effects among system variables, including simultaneous lagged effects recursive (cyclic) dependencies can estimate cumulative outcome press pulse experiments initial conditions differ stationary distribution system dynamics estimates structural linkages regression slopes jointly imputing missing values /measurement errors rapidly fitted Gaussian Markov random field (GMRF) Generalized Linear Mixed Model (GLMM), speed asymptotics associated allows granular control number parameters (restrictions parameters) used structure covariance among variables time, phylosem specifically intended minimal implementation, uses standard packages simplify input/output formatting: Input: time-series defined using class ts, NA missing values Input: structural trade-offs specified using syntax defined package sem Output: visualizing estimated trade-offs using igraph Output: access model output using standard S3-generic functions including summary, predict, residuals, simulate, AIC Please see package vignettes details regarding syntax features.","code":""},{"path":"/reference/TMBAIC.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate marginal AIC for a fitted model — TMBAIC","title":"Calculate marginal AIC for a fitted model — TMBAIC","text":"TMBAIC calculates AIC given model fit","code":""},{"path":"/reference/TMBAIC.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate marginal AIC for a fitted model — TMBAIC","text":"","code":"TMBAIC(opt, k = 2, n = Inf)"},{"path":"/reference/TMBAIC.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate marginal AIC for a fitted model — TMBAIC","text":"opt output nlminb optim k penalty additional fixed effects (default=2, AIC) n sample size, use AICc calculation (default=Inf, AICc=AIC)","code":""},{"path":"/reference/TMBAIC.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate marginal AIC for a fitted model — TMBAIC","text":"AIC, parsimonious model AIC relative candidate models","code":""},{"path":"/reference/as_fitted_DAG.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert output from package dsem to phylopath — as_fitted_DAG","title":"Convert output from package dsem to phylopath — as_fitted_DAG","text":"Convert dsem phylopath output","code":""},{"path":"/reference/as_fitted_DAG.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert output from package dsem to phylopath — as_fitted_DAG","text":"","code":"as_fitted_DAG(fit, lag = 0, what = \"Estimate\", direction = 1)"},{"path":"/reference/as_fitted_DAG.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert output from package dsem to phylopath — as_fitted_DAG","text":"fit Output dsem lag lag output whether output estimates =\"Estimate\", standard errors =\"Std_Error\" p-values =\"Std_Error\" direction whether include one-sided arrows direction=1, one- two-sided arrows direction=c(1,2)","code":""},{"path":"/reference/as_fitted_DAG.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert output from package dsem to phylopath — as_fitted_DAG","text":"Convert output format supplied est_DAG","code":""},{"path":"/reference/as_sem.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert dsem to sem output — as_sem","title":"Convert dsem to sem output — as_sem","text":"Convert output package dsem sem","code":""},{"path":"/reference/as_sem.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert dsem to sem output — as_sem","text":"","code":"as_sem(object, lag = 0)"},{"path":"/reference/as_sem.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert dsem to sem output — as_sem","text":"object Output dsem lag lag extract visualize","code":""},{"path":"/reference/as_sem.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert dsem to sem output — as_sem","text":"Convert output format supplied sem","code":""},{"path":"/reference/bering_sea.html","id":null,"dir":"Reference","previous_headings":"","what":"Bering Sea marine ecosystem — bering_sea","title":"Bering Sea marine ecosystem — bering_sea","text":"Data used demonstrate test ecosystem synthesis","code":""},{"path":"/reference/bering_sea.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Bering Sea marine ecosystem — bering_sea","text":"","code":"data(bering_sea)"},{"path":"/reference/checkDepPackageVersion.html","id":null,"dir":"Reference","previous_headings":"","what":"Check for version mismatch in dependent binary packages — checkDepPackageVersion","title":"Check for version mismatch in dependent binary packages — checkDepPackageVersion","text":"Copied glmmTMB permission","code":""},{"path":"/reference/checkDepPackageVersion.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check for version mismatch in dependent binary packages — checkDepPackageVersion","text":"","code":"checkDepPackageVersion(   dep_pkg = \"TMB\",   this_pkg = \"dsem\",   write_file = FALSE,   warn = TRUE )"},{"path":"/reference/checkDepPackageVersion.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check for version mismatch in dependent binary packages — checkDepPackageVersion","text":"dep_pkg upstream package this_pkg downstream package write_file (logical) write version file quit? warn give warning?","code":""},{"path":"/reference/checkDepPackageVersion.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check for version mismatch in dependent binary packages — checkDepPackageVersion","text":"logical: TRUE binary versions match","code":""},{"path":"/reference/classify_variables.html","id":null,"dir":"Reference","previous_headings":"","what":"Classify variables path — classify_variables","title":"Classify variables path — classify_variables","text":"classify_variables copied sem:::classifyVariables","code":""},{"path":"/reference/classify_variables.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Classify variables path — classify_variables","text":"","code":"classify_variables(model)"},{"path":"/reference/classify_variables.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Classify variables path — classify_variables","text":"model SEM model","code":""},{"path":"/reference/classify_variables.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Classify variables path — classify_variables","text":"Tagged-list defining exogenous endogenous variables","code":""},{"path":"/reference/classify_variables.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Classify variables path — classify_variables","text":"Copied package `sem` licence GPL (>= 2) permission John Fox","code":""},{"path":"/reference/dsem.html","id":null,"dir":"Reference","previous_headings":"","what":"Fit dynamic structural equation model — dsem","title":"Fit dynamic structural equation model — dsem","text":"Fits dynamic structural equation model","code":""},{"path":"/reference/dsem.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fit dynamic structural equation model — dsem","text":"","code":"dsem(   sem,   tsdata,   family = rep(\"fixed\", ncol(tsdata)),   estimate_delta0 = FALSE,   control = dsem_control() )"},{"path":"/reference/dsem.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fit dynamic structural equation model — dsem","text":"sem Specification time-series structural equation model structure including lagged simultaneous effects.  See Details section make_dsem_ram description tsdata time-series data, outputted using ts family Character-vector listing distribution used column tsdata, element must fixed normal. family=\"fixed\" default behavior assumes given variable measured exactly. options correspond different specifications measurement error. estimate_delta0 Boolean indicating whether estimate deviations equilibrium initial year fixed effects, alternatively assume dynamics start stochastic draw away stationary distribution control Output dsem_control, used define user settings, see documentation function details.","code":""},{"path":"/reference/dsem.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fit dynamic structural equation model — dsem","text":"object (list) class `dsem`. Elements include: obj TMB object MakeADFun ram RAM parsed make_dsem_ram model SEM structure parsed make_dsem_ram intermediate description model linkages tmb_inputs list inputs passed MakeADFun opt output nlminb sdrep output sdreport interal Objects useful package function, .e., arguments                passed call","code":""},{"path":"/reference/dsem.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Fit dynamic structural equation model — dsem","text":"DSEM involves (minimum): Time series matrix \\(\\mathbf X\\) column \\(\\mathbf x_c\\) variable c         time-series; Path diagram user-supplied specification path coefficients,         define precision (inverse covariance) \\(\\mathbf Q\\) matrix state-variables         see make_dsem_ram details math involved. model also estimates time-series mean \\( \\mathbf{\\mu}_c \\) variable. mean precision matrix therefore define Gaussian Markov random field \\(\\mathbf X\\): $$ \\mathrm{vec}(\\mathbf X) \\sim \\mathrm{MVN}( \\mathrm{vec}(\\mathbf{I_T} \\otimes \\mathbf{\\mu}), \\mathbf{Q}^{-1}) $$ Users can specify distribution measurement errors (assume variables measured without error) using argument family.  defines link-function \\(g_c(.)\\) distribution \\(f_c(.)\\) time-series \\(c\\): $$ y_{t,c} \\sim f_c( g_c^{-1}( x_{t,c} ), \\theta_c )$$ dsem estimates specified coefficients, time-series means \\(\\mu_c\\), distribution measurement errors \\(\\theta_c\\) via maximizing log-marginal likelihood, also estimating state-variables \\(x_{t,c}\\). summary.dsem assembles estimates standard errors easy--read format. Standard errors fixed effects (path coefficients, exogenoux variance parameters, measurement error parameters) estimated matrix second derivatives log-marginal likelihod, standard errors random effects (.e., missing state-space variables) estimated generalization method (see sdreport details).","code":""},{"path":"/reference/dsem.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Fit dynamic structural equation model — dsem","text":"**Introducing package, features, comparison software (cite using dsem):** Thorson, J. T., Andrews, ., Essington, T., Large, S. (review). Dynamic structural equation models synthesize ecosystem dynamics constrained ecological mechanisms.","code":""},{"path":"/reference/dsem.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fit dynamic structural equation model — dsem","text":"","code":"# Define model sem = \"   # Link, lag, param_name   cprofits -> consumption, 0, a1   cprofits -> consumption, 1, a2   pwage -> consumption, 0, a3   gwage -> consumption, 0, a3   cprofits -> invest, 0, b1   cprofits -> invest, 1, b2   capital -> invest, 0, b3   gnp -> pwage, 0, c2   gnp -> pwage, 1, c3   time -> pwage, 0, c1 \"  # Load data data(KleinI, package=\"AER\") TS = ts(data.frame(KleinI, \"time\"=time(KleinI) - 1931)) tsdata = TS[,c(\"time\",\"gnp\",\"pwage\",\"cprofits\",'consumption',                \"gwage\",\"invest\",\"capital\")]  # Fit model fit = dsem( sem=sem,             tsdata = tsdata,             estimate_delta0 = TRUE,             control = dsem_control(quiet=TRUE) ) #> 1 regions found. #> Using 1 threads #> 1 regions found. #> Using 1 threads summary( fit ) #>                           path lag           name start parameter       first #> 1      cprofits -> consumption   0             a1  <NA>         1    cprofits #> 2      cprofits -> consumption   1             a2  <NA>         2    cprofits #> 3         pwage -> consumption   0             a3  <NA>         3       pwage #> 4         gwage -> consumption   0             a3  <NA>         3       gwage #> 5           cprofits -> invest   0             b1  <NA>         4    cprofits #> 6           cprofits -> invest   1             b2  <NA>         5    cprofits #> 7            capital -> invest   0             b3  <NA>         6     capital #> 8                 gnp -> pwage   0             c2  <NA>         7         gnp #> 9                 gnp -> pwage   1             c3  <NA>         8         gnp #> 10               time -> pwage   0             c1  <NA>         9        time #> 11               time <-> time   0        V[time]  <NA>        10        time #> 12                 gnp <-> gnp   0         V[gnp]  <NA>        11         gnp #> 13             pwage <-> pwage   0       V[pwage]  <NA>        12       pwage #> 14       cprofits <-> cprofits   0    V[cprofits]  <NA>        13    cprofits #> 15 consumption <-> consumption   0 V[consumption]  <NA>        14 consumption #> 16             gwage <-> gwage   0       V[gwage]  <NA>        15       gwage #> 17           invest <-> invest   0      V[invest]  <NA>        16      invest #> 18         capital <-> capital   0     V[capital]  <NA>        17     capital #>         second direction    Estimate  Std_Error   z_value       p_value #> 1  consumption         1  0.19323185 0.08199229  2.356708  1.843776e-02 #> 2  consumption         1  0.08942112 0.08136334  1.099035  2.717530e-01 #> 3  consumption         1  0.79625663 0.03594118 22.154439 9.452934e-109 #> 4  consumption         1  0.79625663 0.03594118 22.154439 9.452934e-109 #> 5       invest         1  0.48138141 0.08740019  5.507785  3.633777e-08 #> 6       invest         1  0.33084616 0.09069261  3.647995  2.642950e-04 #> 7       invest         1 -0.11150752 0.02408258 -4.630214  3.652875e-06 #> 8        pwage         1  0.44041577 0.02921824 15.073314  2.426312e-51 #> 9        pwage         1  0.14476511 0.03370693  4.294817  1.748376e-05 #> 10       pwage         1  0.13029837 0.02882711  4.519995  6.184119e-06 #> 11        time         2  6.05530071 0.93435313  6.480741  9.127318e-11 #> 12         gnp         2 10.32020497 1.58102475  6.527542  6.685791e-11 #> 13       pwage         2  0.69302930 0.10701058  6.476269  9.401826e-11 #> 14    cprofits         2  4.10929046 0.63141034  6.508114  7.610017e-11 #> 15 consumption         2  0.92285232 0.14239896  6.480752  9.126683e-11 #> 16       gwage         2  1.90952975 0.29464666  6.480745  9.127100e-11 #> 17      invest         2  0.91015034 0.14046563  6.479523  9.201284e-11 #> 18     capital         2  9.67950590 1.49358015  6.480741  9.127332e-11 plot( fit )  plot( fit, edge_label=\"value\" )"},{"path":"/reference/dsem_control.html","id":null,"dir":"Reference","previous_headings":"","what":"Detailed control for dsem structure — dsem_control","title":"Detailed control for dsem structure — dsem_control","text":"Define list control parameters.  Note format input likely change rapidly dsem","code":""},{"path":"/reference/dsem_control.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Detailed control for dsem structure — dsem_control","text":"","code":"dsem_control(   nlminb_loops = 1,   newton_loops = 1,   trace = 0,   eval.max = 1000,   iter.max = 1000,   getsd = TRUE,   quiet = FALSE,   run_model = TRUE,   use_REML = TRUE,   parameters = NULL,   map = NULL,   getJointPrecision = FALSE )"},{"path":"/reference/dsem_control.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Detailed control for dsem structure — dsem_control","text":"nlminb_loops Integer number times call nlminb. newton_loops Integer number Newton steps running nlminb. trace Parameter values printed every `trace` iteration outer optimizer. Passed `control` nlminb. eval.max Maximum number evaluations objective function allowed. Passed `control` nlminb. iter.max Maximum number iterations allowed. Passed `control` nlminb. getsd Boolean indicating whether call sdreport quiet Boolean indicating whether run model printing messages terminal ; run_model Boolean indicating whether estimate parameters (default), instead return model inputs compiled TMB object without running; use_REML Boolean indicating whether treat non-variance fixed effects random, either motigate bias estimated variance parameters improve efficiency parameter estimation given correlated fixed random effects parameters list fixed random effects, e.g., constructed dsem modified hand (helpful advanced users change starting values restart intended values) map list fixed mirrored parameters, constructed dsem default available override default pass MakeADFun getJointPrecision whether get joint precision matrix.  Passed sdreport.","code":""},{"path":"/reference/dsem_control.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Detailed control for dsem structure — dsem_control","text":"S3 object class \"dsem_control\" specifies detailed model settings, allowing user specification also specifying default values","code":""},{"path":"/reference/isle_royale.html","id":null,"dir":"Reference","previous_headings":"","what":"Isle Royale wolf and moose — isle_royale","title":"Isle Royale wolf and moose — isle_royale","text":"Data used demonstrate test cross-lagged (vector autoregressive) models","code":""},{"path":"/reference/isle_royale.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Isle Royale wolf and moose — isle_royale","text":"","code":"data(isle_royale)"},{"path":"/reference/isle_royale.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Isle Royale wolf and moose — isle_royale","text":"Data extracted file \"Data_wolves_moose_Isle_Royale_June2019.csv\" available https://isleroyalewolf.org/data/data/home.html obtained 2023-06-23. Reproduced permission John Vucetich, generated Wolves Moose Isle Royale project.","code":""},{"path":"/reference/isle_royale.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Isle Royale wolf and moose — isle_royale","text":"Vucetich, JA Peterson RO. 2012. population biology Isle Royale wolves moose: overview. https://www.isleroyalewolf.org","code":""},{"path":"/reference/list_parameters.html","id":null,"dir":"Reference","previous_headings":"","what":"List fixed and random effects — list_parameters","title":"List fixed and random effects — list_parameters","text":"list_parameters lists fixed random effects","code":""},{"path":"/reference/list_parameters.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"List fixed and random effects — list_parameters","text":"","code":"list_parameters(Obj, verbose = TRUE)"},{"path":"/reference/list_parameters.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"List fixed and random effects — list_parameters","text":"Obj Compiled TMB object verbose Boolean, whether print messages terminal","code":""},{"path":"/reference/list_parameters.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"List fixed and random effects — list_parameters","text":"Tagged-list fixed random effects, returned invisibly printed screen","code":""},{"path":"/reference/logLik.dsem.html","id":null,"dir":"Reference","previous_headings":"","what":"Marglinal log-likelihood — logLik.dsem","title":"Marglinal log-likelihood — logLik.dsem","text":"Extract (marginal) log-likelihood dsem model","code":""},{"path":"/reference/logLik.dsem.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Marglinal log-likelihood — logLik.dsem","text":"","code":"# S3 method for dsem logLik(object, ...)"},{"path":"/reference/logLik.dsem.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Marglinal log-likelihood — logLik.dsem","text":"object Output dsem ... used","code":""},{"path":"/reference/logLik.dsem.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Marglinal log-likelihood — logLik.dsem","text":"object class logLik attributes val log-likelihood df number parameters Returns object class logLik. attributes \"df\" (degrees freedom) giving number (estimated) fixed effects model, abd \"val\" (value) giving marginal log-likelihood. class allows AIC work expected.","code":""},{"path":"/reference/make_dsem_ram.html","id":null,"dir":"Reference","previous_headings":"","what":"Make a RAM (Reticular Action Model) — make_dsem_ram","title":"Make a RAM (Reticular Action Model) — make_dsem_ram","text":"make_dsem_ram converts SEM arrow notation ram describing SEM parameters","code":""},{"path":"/reference/make_dsem_ram.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Make a RAM (Reticular Action Model) — make_dsem_ram","text":"","code":"make_dsem_ram(   sem,   times,   variables,   covs = NULL,   quiet = FALSE,   remove_na = TRUE )"},{"path":"/reference/make_dsem_ram.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Make a RAM (Reticular Action Model) — make_dsem_ram","text":"sem Specification time-series structural equation model structure including lagged simultaneous effects.  See Details section make_dsem_ram description times character vector listing set times order variables character vector listing set variables covs character vector listing variables estimate standard deviation quiet Boolean indicating whether print messages terminal remove_na Boolean indicating whether remove NA values RAM (default) . remove_NA=FALSE might useful exploration diagnostics advanced users","code":""},{"path":"/reference/make_dsem_ram.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Make a RAM (Reticular Action Model) — make_dsem_ram","text":"reticular action module (RAM) describing dependencies","code":""},{"path":"/reference/make_dsem_ram.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Make a RAM (Reticular Action Model) — make_dsem_ram","text":"RAM specification using arrow--lag notation line RAM specification make_dsem_ram consists four (unquoted) entries, separated commas: 1. Arrow specification: simple formula, form     -> B , equivalently, B <- regression     coefficient (.e., single-headed directional arrow);     <-> variance <-> B covariance     (.e., double-headed bidirectional arrow). ,     B variable names model. name correspond     observed variable, assumed latent variable.     Spaces can appear freely arrow specification,     can number hyphens arrows, including zero: Thus,     e.g., ->B, --> B, >B legitimate     equivalent. 2. Lag (using positive values): integer specifying whether linkage     simultaneous (lag=0) lagged (e.g., X -> Y, 1, XtoY     indicates X time T affects Y time T+1),     one-headed arrows can lagged. Using positive values indicate lags      matches notational convention used package dynlm. 3. Parameter name: name regression coefficient, variance,     covariance specified arrow. Assigning name two     arrows results equality constraint. Specifying parameter name     NA produces fixed parameter. 4. Value: start value free parameter value fixed parameter.     given NA (simply omitted), model provide default     starting value. Lines may end comment following #. function extends code copied package `sem` licence GPL (>= 2) permission John Fox. Simultaneous autoregressive process simultaneous lagged effects text specifies linkages multivariate time-series model variables \\(\\mathbf X\\) dimensions \\(T \\times C\\) \\(T\\) times \\(C\\) variables. make_dsem_ram parses text build path matrix \\(\\mathbf{P}\\) dimensions \\(TC \\times TC\\), element \\(\\rho_{k_2,k_1}\\) represents impact \\(x_{t_1,c_1}\\) \\(x_{t_2,c_2}\\), \\(k_1=T c_1+t_1\\) \\(k_2=T c_2+t_2\\).  path matrix defines simultaneous equation $$ \\mathrm{vec}(\\mathbf X) = \\mathbf P \\mathrm{vec}(\\mathbf X) + \\mathrm{vec}(\\mathbf \\Delta)$$ \\(\\mathbf \\Delta\\) matrix exogenous errors covariance \\(\\mathbf{V = \\Gamma \\Gamma}^t\\), \\(\\mathbf \\Gamma\\) Cholesky exogenous covariance.  simultaneous autoregressive (SAR) process results \\(\\mathbf X\\) covariance: $$ \\mathrm{Cov}(\\mathbf X) = \\mathbf{(- P)}^{-1} \\mathbf{\\Gamma \\Gamma}^t \\mathbf{((- P)}^{-1})^t $$ Usefully, computing inverse-covariance (precision) matrix \\(\\mathbf{Q = V}^{-1}\\) require inverting \\(\\mathbf{(- P)}\\): $$ \\mathbf{Q} = (\\mathbf{\\Gamma}^{-1} \\mathbf{(- P)})^t \\mathbf{\\Gamma}^{-1} \\mathbf{(- P)} $$ Example: univariate first-order autoregressive model simultaneous autoregressive (SAR) process across variables times allows user specify simutanous effects (effects among variables within year \\(T\\)) lagged effects (effects among variables among years \\(T\\)). one example, consider univariate first-order autoregressive process \\(T=4\\). independent errors.  specified passing  sem = \"X -> X, 1, rho \\n X <-> X, 0, sigma\"  make_dsem_ram. parsed RAM: Rows RAM heads=1 interpreted construct path matrix \\(\\mathbf P\\), column \"\" RAM indicates column number matrix, column \"\" RAM indicates row number matrix: $$ \\mathbf P = \\begin{bmatrix}     0 & 0 & 0 & 0 \\\\     \\rho & 0 & 0 & 0 \\\\     0 & \\rho & 0 & 0 \\\\     0 & 0 & \\rho & 0\\\\     \\end{bmatrix} $$ rows heads=2 interpreted construct Cholesky exogenous covariance \\(\\mathbf \\Gamma\\) column \"parameter\" RAM associates nonzero element two matrices element vector estimated parameters: $$ \\mathbf \\Gamma = \\begin{bmatrix}     \\sigma & 0 & 0 & 0 \\\\     0 & \\sigma & 0 & 0 \\\\     0 & 0 & \\sigma & 0 \\\\     0 & 0 & 0 & \\sigma\\\\     \\end{bmatrix} $$ two estimated parameters \\(\\mathbf \\beta = (\\rho, \\sigma) \\). results covariance: $$ \\mathrm{Cov}(\\mathbf X) = \\sigma^2 \\begin{bmatrix}     1      & \\rho^1              & \\rho^2                        & \\rho^3                  \\\\     \\rho^1 & 1 + \\rho^2          & \\rho^1 (1 + \\rho^2)           & \\rho^2 (1 + \\rho^2)     \\\\     \\rho^2 & \\rho^1 (1 + \\rho^2) & 1 + \\rho^2 + \\rho^4           & \\rho^1 (1 + \\rho^2 + \\rho^4)                 \\\\     \\rho^3 & \\rho^2 (1 + \\rho^2) & \\rho^1 (1 + \\rho^2 + \\rho^4)  & 1 + \\rho^2 + \\rho^4 + \\rho^6 \\\\     \\end{bmatrix} $$ converges stationary covariance AR1 process times \\(t>>1\\): $$ \\mathrm{Cov}(\\mathbf X) = \\frac{\\sigma^2}{1+\\rho^2} \\begin{bmatrix}     1 & \\rho^1 & \\rho^2 & \\rho^3 \\\\     \\rho^1 & 1 & \\rho^1 & \\rho^2 \\\\     \\rho^2 & \\rho^1 & 1 & \\rho^1 \\\\     \\rho^3 & \\rho^2 & \\rho^1 & 1\\\\     \\end{bmatrix} $$ except lower pointwise variance initial times, arises \"boundary effect\". Similarly, arrow--lag notation can used specify SAR representing conventional structural equation model (SEM), cross-lagged (.k.. vector autoregressive) models (VAR), dynamic factor analysis (DFA), many time-series models.","code":""},{"path":"/reference/make_dsem_ram.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Make a RAM (Reticular Action Model) — make_dsem_ram","text":"","code":"# Univariate AR1 sem = \"   X -> X, 1, rho   X <-> X, 0, sigma \" make_dsem_ram( sem=sem, variables=\"X\", times=1:4 ) #> $model #>      path      lag name    start parameter first second direction #> [1,] \"X -> X\"  \"1\" \"rho\"   NA    \"1\"       \"X\"   \"X\"    \"1\"       #> [2,] \"X <-> X\" \"0\" \"sigma\" NA    \"2\"       \"X\"   \"X\"    \"2\"       #>  #> $ram #>   heads to from parameter start #> 1     1  2    1         1  <NA> #> 2     1  3    2         1  <NA> #> 3     1  4    3         1  <NA> #> 5     2  1    1         2  <NA> #> 6     2  2    2         2  <NA> #> 7     2  3    3         2  <NA> #> 8     2  4    4         2  <NA> #>  #> $variables #> [1] \"X\" #>  #> $times #> [1] 1 2 3 4 #>  #> attr(,\"class\") #> [1] \"dsem_ram\"  # Univariate AR2 sem = \"   X -> X, 1, rho1   X -> X, 2, rho2   X <-> X, 0, sigma \" make_dsem_ram( sem=sem, variables=\"X\", times=1:4 ) #> $model #>      path      lag name    start parameter first second direction #> [1,] \"X -> X\"  \"1\" \"rho1\"  NA    \"1\"       \"X\"   \"X\"    \"1\"       #> [2,] \"X -> X\"  \"2\" \"rho2\"  NA    \"2\"       \"X\"   \"X\"    \"1\"       #> [3,] \"X <-> X\" \"0\" \"sigma\" NA    \"3\"       \"X\"   \"X\"    \"2\"       #>  #> $ram #>    heads to from parameter start #> 1      1  2    1         1  <NA> #> 2      1  3    2         1  <NA> #> 3      1  4    3         1  <NA> #> 5      1  3    1         2  <NA> #> 6      1  4    2         2  <NA> #> 9      2  1    1         3  <NA> #> 10     2  2    2         3  <NA> #> 11     2  3    3         3  <NA> #> 12     2  4    4         3  <NA> #>  #> $variables #> [1] \"X\" #>  #> $times #> [1] 1 2 3 4 #>  #> attr(,\"class\") #> [1] \"dsem_ram\"  # Bivariate VAR sem = \"   X -> X, 1, XtoX   X -> Y, 1, XtoY   Y -> X, 1, YtoX   Y -> Y, 1, YtoY   X <-> X, 0, sdX   Y <-> Y, 0, sdY \" make_dsem_ram( sem=sem, variables=c(\"X\",\"Y\"), times=1:4 ) #> $model #>      path      lag name   start parameter first second direction #> [1,] \"X -> X\"  \"1\" \"XtoX\" NA    \"1\"       \"X\"   \"X\"    \"1\"       #> [2,] \"X -> Y\"  \"1\" \"XtoY\" NA    \"2\"       \"X\"   \"Y\"    \"1\"       #> [3,] \"Y -> X\"  \"1\" \"YtoX\" NA    \"3\"       \"Y\"   \"X\"    \"1\"       #> [4,] \"Y -> Y\"  \"1\" \"YtoY\" NA    \"4\"       \"Y\"   \"Y\"    \"1\"       #> [5,] \"X <-> X\" \"0\" \"sdX\"  NA    \"5\"       \"X\"   \"X\"    \"2\"       #> [6,] \"Y <-> Y\" \"0\" \"sdY\"  NA    \"6\"       \"Y\"   \"Y\"    \"2\"       #>  #> $ram #>    heads to from parameter start #> 1      1  2    1         1  <NA> #> 2      1  3    2         1  <NA> #> 3      1  4    3         1  <NA> #> 5      1  6    1         2  <NA> #> 6      1  7    2         2  <NA> #> 7      1  8    3         2  <NA> #> 9      1  2    5         3  <NA> #> 10     1  3    6         3  <NA> #> 11     1  4    7         3  <NA> #> 13     1  6    5         4  <NA> #> 14     1  7    6         4  <NA> #> 15     1  8    7         4  <NA> #> 17     2  1    1         5  <NA> #> 18     2  2    2         5  <NA> #> 19     2  3    3         5  <NA> #> 20     2  4    4         5  <NA> #> 21     2  5    5         6  <NA> #> 22     2  6    6         6  <NA> #> 23     2  7    7         6  <NA> #> 24     2  8    8         6  <NA> #>  #> $variables #> [1] \"X\" \"Y\" #>  #> $times #> [1] 1 2 3 4 #>  #> attr(,\"class\") #> [1] \"dsem_ram\"  # Dynamic factor analysis with one factor and two manifest variables # (specifies a random-walk for the factor, and miniscule residual SD) sem = \"   factor -> X, 0, loadings1   factor -> Y, 0, loadings2   factor -> factor, 1, NA, 1   X <-> X, 0, NA, 0.01       # Fix at negligible value   Y <-> Y, 0, NA, 0.01       # Fix at negligible value \" make_dsem_ram( sem=sem, variables=c(\"X\",\"Y\",\"factor\"), times=1:4 ) #> NOTE: adding 1 variances to the model #> $model #>      path                lag name        start  parameter first    second   #> [1,] \"factor -> X\"       \"0\" \"loadings1\" NA     \"1\"       \"factor\" \"X\"      #> [2,] \"factor -> Y\"       \"0\" \"loadings2\" NA     \"2\"       \"factor\" \"Y\"      #> [3,] \"factor -> factor\"  \"1\" NA          \"1\"    \"0\"       \"factor\" \"factor\" #> [4,] \"X <-> X\"           \"0\" NA          \"0.01\" \"0\"       \"X\"      \"X\"      #> [5,] \"Y <-> Y\"           \"0\" NA          \"0.01\" \"0\"       \"Y\"      \"Y\"      #> [6,] \"factor <-> factor\" \"0\" \"V[factor]\" NA     \"3\"       \"factor\" \"factor\" #>      direction #> [1,] \"1\"       #> [2,] \"1\"       #> [3,] \"1\"       #> [4,] \"2\"       #> [5,] \"2\"       #> [6,] \"2\"       #>  #> $ram #>    heads to from parameter start #> 1      1  1    9         1  <NA> #> 2      1  2   10         1  <NA> #> 3      1  3   11         1  <NA> #> 4      1  4   12         1  <NA> #> 5      1  5    9         2  <NA> #> 6      1  6   10         2  <NA> #> 7      1  7   11         2  <NA> #> 8      1  8   12         2  <NA> #> 9      1 10    9         0     1 #> 10     1 11   10         0     1 #> 11     1 12   11         0     1 #> 13     2  1    1         0  0.01 #> 14     2  2    2         0  0.01 #> 15     2  3    3         0  0.01 #> 16     2  4    4         0  0.01 #> 17     2  5    5         0  0.01 #> 18     2  6    6         0  0.01 #> 19     2  7    7         0  0.01 #> 20     2  8    8         0  0.01 #> 21     2  9    9         3  <NA> #> 22     2 10   10         3  <NA> #> 23     2 11   11         3  <NA> #> 24     2 12   12         3  <NA> #>  #> $variables #> [1] \"X\"      \"Y\"      \"factor\" #>  #> $times #> [1] 1 2 3 4 #>  #> attr(,\"class\") #> [1] \"dsem_ram\"  # ARIMA(1,1,0) sem = \"   factor -> factor, 1, rho1 # AR1 component   X -> X, 1, NA, 1          # Integrated component   factor -> X, 0, NA, 1   X <-> X, 0, NA, 0.01      # Fix at negligible value \" make_dsem_ram( sem=sem, variables=c(\"X\",\"factor\"), times=1:4 ) #> NOTE: adding 1 variances to the model #> $model #>      path                lag name        start  parameter first    second   #> [1,] \"factor -> factor\"  \"1\" \"rho1\"      NA     \"1\"       \"factor\" \"factor\" #> [2,] \"X -> X\"            \"1\" NA          \"1\"    \"0\"       \"X\"      \"X\"      #> [3,] \"factor -> X\"       \"0\" NA          \"1\"    \"0\"       \"factor\" \"X\"      #> [4,] \"X <-> X\"           \"0\" NA          \"0.01\" \"0\"       \"X\"      \"X\"      #> [5,] \"factor <-> factor\" \"0\" \"V[factor]\" NA     \"2\"       \"factor\" \"factor\" #>      direction #> [1,] \"1\"       #> [2,] \"1\"       #> [3,] \"1\"       #> [4,] \"2\"       #> [5,] \"2\"       #>  #> $ram #>    heads to from parameter start #> 1      1  6    5         1  <NA> #> 2      1  7    6         1  <NA> #> 3      1  8    7         1  <NA> #> 5      1  2    1         0     1 #> 6      1  3    2         0     1 #> 7      1  4    3         0     1 #> 9      1  1    5         0     1 #> 10     1  2    6         0     1 #> 11     1  3    7         0     1 #> 12     1  4    8         0     1 #> 13     2  1    1         0  0.01 #> 14     2  2    2         0  0.01 #> 15     2  3    3         0  0.01 #> 16     2  4    4         0  0.01 #> 17     2  5    5         2  <NA> #> 18     2  6    6         2  <NA> #> 19     2  7    7         2  <NA> #> 20     2  8    8         2  <NA> #>  #> $variables #> [1] \"X\"      \"factor\" #>  #> $times #> [1] 1 2 3 4 #>  #> attr(,\"class\") #> [1] \"dsem_ram\"  # ARIMA(0,0,1) sem = \"   factor -> X, 0, NA, 1   factor -> X, 1, rho1     # MA1 component   X <-> X, 0, NA, 0.01     # Fix at negligible value \" make_dsem_ram( sem=sem, variables=c(\"X\",\"factor\"), times=1:4 ) #> NOTE: adding 1 variances to the model #> $model #>      path                lag name        start  parameter first    second   #> [1,] \"factor -> X\"       \"0\" NA          \"1\"    \"0\"       \"factor\" \"X\"      #> [2,] \"factor -> X\"       \"1\" \"rho1\"      NA     \"1\"       \"factor\" \"X\"      #> [3,] \"X <-> X\"           \"0\" NA          \"0.01\" \"0\"       \"X\"      \"X\"      #> [4,] \"factor <-> factor\" \"0\" \"V[factor]\" NA     \"2\"       \"factor\" \"factor\" #>      direction #> [1,] \"1\"       #> [2,] \"1\"       #> [3,] \"2\"       #> [4,] \"2\"       #>  #> $ram #>    heads to from parameter start #> 1      1  1    5         0     1 #> 2      1  2    6         0     1 #> 3      1  3    7         0     1 #> 4      1  4    8         0     1 #> 5      1  2    5         1  <NA> #> 6      1  3    6         1  <NA> #> 7      1  4    7         1  <NA> #> 9      2  1    1         0  0.01 #> 10     2  2    2         0  0.01 #> 11     2  3    3         0  0.01 #> 12     2  4    4         0  0.01 #> 13     2  5    5         2  <NA> #> 14     2  6    6         2  <NA> #> 15     2  7    7         2  <NA> #> 16     2  8    8         2  <NA> #>  #> $variables #> [1] \"X\"      \"factor\" #>  #> $times #> [1] 1 2 3 4 #>  #> attr(,\"class\") #> [1] \"dsem_ram\""},{"path":"/reference/parse_path.html","id":null,"dir":"Reference","previous_headings":"","what":"Parse path — parse_path","title":"Parse path — parse_path","text":"parse_path copied sem::parse.path","code":""},{"path":"/reference/parse_path.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Parse path — parse_path","text":"","code":"parse_path(path)"},{"path":"/reference/parse_path.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Parse path — parse_path","text":"path text parse","code":""},{"path":"/reference/parse_path.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Parse path — parse_path","text":"Tagged-list defining variables direction specified path coefficient","code":""},{"path":"/reference/parse_path.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Parse path — parse_path","text":"Copied package `sem` licence GPL (>= 2) permission John Fox","code":""},{"path":"/reference/plot.dsem.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate dsem — plot.dsem","title":"Simulate dsem — plot.dsem","text":"Plot fitted dsem model","code":""},{"path":"/reference/plot.dsem.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate dsem — plot.dsem","text":"","code":"# S3 method for dsem plot(x, y, edge_label = c(\"name\", \"value\"), digits = 2, ...)"},{"path":"/reference/plot.dsem.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate dsem — plot.dsem","text":"x Output dsem y used edge_label Whether plot parameter names estimated values digits integer indicating number decimal places used ... arguments passed plot.igraph","code":""},{"path":"/reference/plot.dsem.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate dsem — plot.dsem","text":"Invisibly returns output graph_from_data_frame passed plot.igraph plotting.","code":""},{"path":"/reference/plot.dsem.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Simulate dsem — plot.dsem","text":"function coerces output graph plots graph.","code":""},{"path":"/reference/predict.dsem.html","id":null,"dir":"Reference","previous_headings":"","what":"predictions using dsem — predict.dsem","title":"predictions using dsem — predict.dsem","text":"Predict variables given new (counterfactual) values data, future past times","code":""},{"path":"/reference/predict.dsem.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"predictions using dsem — predict.dsem","text":"","code":"# S3 method for dsem predict(object, newdata = NULL, type = c(\"link\", \"response\"), ...)"},{"path":"/reference/predict.dsem.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"predictions using dsem — predict.dsem","text":"object Output dsem newdata optionally, data frame look variables predict. omitted, fitted data used create predictions. desiring predictions fitted data, user must append rows NAs future times.  Similarly, desiring predictions given counterfactual values time-series data, individual observations can edited keeping observations original fitted values. type type prediction required. default scale linear predictors; alternative \"response\" scale response variable. Thus Poisson-distributed variable default predictions log-intensity type = \"response\" gives predicted intensity. ... used","code":""},{"path":"/reference/predict.dsem.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"predictions using dsem — predict.dsem","text":"matrix predicted values dimensions order corresponding argument newdata provided, tsdata . Predictions provided either link response scale, generated re-optimizing random effects condition MLE fixed effects, given new data.","code":""},{"path":"/reference/print.dsem.html","id":null,"dir":"Reference","previous_headings":"","what":"Print fitted dsem object — print.dsem","title":"Print fitted dsem object — print.dsem","text":"Prints output fitted dsem model","code":""},{"path":"/reference/print.dsem.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print fitted dsem object — print.dsem","text":"","code":"# S3 method for dsem print(x, ...)"},{"path":"/reference/print.dsem.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print fitted dsem object — print.dsem","text":"x Output dsem ... used","code":""},{"path":"/reference/print.dsem.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print fitted dsem object — print.dsem","text":"return value, called provide clean terminal output calling fitted object terminal.","code":""},{"path":"/reference/reinstalling.html","id":null,"dir":"Reference","previous_headings":"","what":"Reinstalling binary dependencies — reinstalling","title":"Reinstalling binary dependencies — reinstalling","text":"dsem package depends several upstream packages, uses way depends heavily internal (binary) structure. Sometimes, therefore, installing update one packages require re-install binary-compatible version dsem, .e. version compiled updated version upstream package. development tools (compilers etc.) installed, able re-install binary-compatible version package running install.packages(\"dsem\", type=\"source\"). want install development version dsem instead, can use remotes::install_github(\"James-Thorson-NOAA/dsem\"). (Windows, can install development tools following instructions https://cran.r-project.org/bin/windows/Rtools/; MacOS, see https://mac.r-project.org/tools/.) development tools /want install (install packages compiled code source), can revert upstream package(s) previous binary version. example, using checkpoint package: similar recipe (substituting Matrix TMB TMB dsem) can used get warnings incompatibility TMB Matrix.","code":"## load (installing if necessary) the checkpoint package while (!require(\"checkpoint\")) install.packages(\"checkpoint\") ## retrieve build date of installed version of dsem bd <- as.character(asDateBuilt(       packageDescription(\"dsem\",fields=\"Built\"))) oldrepo <- getOption(\"repos\") use_mran_snapshot(bd) ## was setSnapshot() pre-checkpoint v1.0.0 install.packages(\"TMB\") options(repos=oldrepo) ## restore original repo"},{"path":"/reference/reinstalling.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Reinstalling binary dependencies — reinstalling","text":"Copied glmmTMB permission","code":""},{"path":"/reference/residuals.dsem.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate residuals — residuals.dsem","title":"Calculate residuals — residuals.dsem","text":"Calculate deviance response residuals dsem","code":""},{"path":"/reference/residuals.dsem.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate residuals — residuals.dsem","text":"","code":"# S3 method for dsem residuals(object, type = c(\"deviance\", \"response\"), ...)"},{"path":"/reference/residuals.dsem.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate residuals — residuals.dsem","text":"object Output dsem type type residuals compute (option \"deviance\" \"response\" now) ... used","code":""},{"path":"/reference/residuals.dsem.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate residuals — residuals.dsem","text":"matrix residuals, order dimensions argument tsdata passed dsem.","code":""},{"path":"/reference/sea_otter.html","id":null,"dir":"Reference","previous_headings":"","what":"Sea otter trophic cascade — sea_otter","title":"Sea otter trophic cascade — sea_otter","text":"Data used demonstrate test trophic cascades options","code":""},{"path":"/reference/sea_otter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sea otter trophic cascade — sea_otter","text":"","code":"data(sea_otter)"},{"path":"/reference/simulate.dsem.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate dsem — simulate.dsem","title":"Simulate dsem — simulate.dsem","text":"Simulate fitted dsem model","code":""},{"path":"/reference/simulate.dsem.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate dsem — simulate.dsem","text":"","code":"# S3 method for dsem simulate(   object,   nsim = 1,   seed = NULL,   variance = c(\"none\", \"random\", \"both\"),   resimulate_gmrf = FALSE,   ... )"},{"path":"/reference/simulate.dsem.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate dsem — simulate.dsem","text":"object Output dsem nsim number simulated data sets seed random seed variance whether ignore uncertainty fixed random effects, include estimation uncertainty random effects, include estimation uncertainty fixed random effects resimulate_gmrf whether resimulate GMRF based estimated simulated random effects (determined argument variance) ... used","code":""},{"path":"/reference/simulate.dsem.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate dsem — simulate.dsem","text":"Simulated data, either obj$simulate obj compiled TMB object, first simulating new GMRF calling obj$simulate.","code":""},{"path":"/reference/simulate.dsem.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Simulate dsem — simulate.dsem","text":"function conducts parametric bootstrap, .e., simulates new data conditional upon estimated values fixed random effects.  user can optionally simulate new random effects conditional upon estimated covariance, simulate new fixed random effects conditional upon imprecision. Note simulate effect states x_tj measurement measurements fitted using family=\"fixed\", unless resimulate_gmrf=TRUE.  latter case, GMRF resimulated given estimated path coefficients","code":""},{"path":"/reference/summary.dsem.html","id":null,"dir":"Reference","previous_headings":"","what":"summarize dsem — summary.dsem","title":"summarize dsem — summary.dsem","text":"summarize parameters fitted dynamic structural equation model","code":""},{"path":"/reference/summary.dsem.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"summarize dsem — summary.dsem","text":"","code":"# S3 method for dsem summary(object, ...)"},{"path":"/reference/summary.dsem.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"summarize dsem — summary.dsem","text":"object Output dsem ... used","code":""},{"path":"/reference/summary.dsem.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"summarize dsem — summary.dsem","text":"Returns data.frame summarizing estimated path coefficients, containing columns: path parsed path coefficient lag lag, e.g. 1 means predictor time t effects response time t+1 name Parameter name start Start value supplied, NA otherwise parameter Parameter number first Variable path treated predictor second Variable path treated response direction Whether path one-headed two-headed Estimate Maximum likelihood estimate Std_Error Estimated standard error Hessian matrix z_value Estimate divided Std_Error p_value P-value associated z_value using two-sided Wald test","code":""},{"path":"/reference/summary.dsem.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"summarize dsem — summary.dsem","text":"DSEM specified using \"arrow lag\" notation, specifies set path coefficients exogenous variance parameters estimated. Function dsem estimates maximum likelihood value coefficients parameters maximizing log-marginal likelihood.  Standard errors parameters calculated matrix second derivatives log-marginal likelihood (\"Hessian matrix\"). However, many users want associate individual parameters standard errors path coefficients specified using \"arrow lag\" notation. task complicated models path coefficients variance parameters specified share single value priori, assigned name NA hence assumed fixed value priori (coefficients parameters assigned value standard error). summary function therefore compiles MLE coefficients (including duplicating values path coefficients assigned value) standard error estimates, outputs table associates user-supplied path parameter names. also outputs z-score p-value arising two-sided Wald test (.e. comparing estimate divided standard error standard normal distribution).","code":""},{"path":"/reference/vcov.dsem.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract Variance-Covariance Matrix — vcov.dsem","title":"Extract Variance-Covariance Matrix — vcov.dsem","text":"extract covariance fixed effects, fixed random effects.","code":""},{"path":"/reference/vcov.dsem.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract Variance-Covariance Matrix — vcov.dsem","text":"","code":"# S3 method for dsem vcov(object, which = c(\"fixed\", \"random\", \"both\"), ...)"},{"path":"/reference/vcov.dsem.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract Variance-Covariance Matrix — vcov.dsem","text":"object output dsem whether extract covariance among fixed effects, random effects, ... ignored, method compatibility","code":""},{"path":"/reference/vcov.dsem.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract Variance-Covariance Matrix — vcov.dsem","text":"square matrix containing estimated covariances among parameter estimates model. dimensions dependend upon argument , determine whether fixed, random effects, outputted.","code":""},{"path":"/news/index.html","id":"dsem-102","dir":"Changelog","previous_headings":"","what":"dsem 1.0.2","title":"dsem 1.0.2","text":"CRAN release: 2024-02-02 Eliminate eval usage Add codecov Action badge Change default behavior variables tsdata standard deviation default","code":""},{"path":"/news/index.html","id":"dsem-101","dir":"Changelog","previous_headings":"","what":"dsem 1.0.1","title":"dsem 1.0.1","text":"CRAN release: 2024-01-18 Fix bug simulate.dsem keep changing interface dsem Update CITATION indicate accepted paper Remove fit_tmb eliminate cryptic warning messages simplify code","code":""},{"path":"/news/index.html","id":"dsem-100","dir":"Changelog","previous_headings":"","what":"dsem 1.0.0","title":"dsem 1.0.0","text":"CRAN release: 2023-12-08 Initial public release","code":""}]
