[{"path":"/articles/dynamic_factor_analysis.html","id":"dynamic-factor-analysis","dir":"Articles","previous_headings":"","what":"Dynamic factor analysis","title":"Dynamic factor analysis","text":"dsem R package fitting dynamic structural equation models (DSEMs) simple user-interface generic specification simultaneous lagged effects potentially recursive structure. , highlight DSEM can used implement dynamic factor analysis (DFA). specifically replicate analysis using Multivariate Autoregressive State-Space (MARSS) package, using data provided example MARSS package.","code":"library(dsem) library(MARSS) library(ggplot2) data( harborSealWA, package=\"MARSS\")  # Define helper function grab = \\(x,name) x[which(names(x)==name)]   # Define number of factors # n_factors >= 3 doesn't seem to converge using DSEM or MARSS without penalties n_factors = 2"},{"path":"/articles/dynamic_factor_analysis.html","id":"using-marss","dir":"Articles","previous_headings":"","what":"Using MARSS","title":"Dynamic factor analysis","text":"first illustrate DFA model using two factors, fitted using MARSS: can plot estimated factors (latent variables):  estimated predictor measurements (manifest variables):","code":"# Load data dat <- t(scale(harborSealWA[,c(\"SJI\",\"EBays\",\"SJF\",\"PSnd\",\"HC\")]))  # DFA with 3 states; used BFGS because it fits much faster for this model fit_MARSS <- MARSS( dat,                      model = list(m=n_factors),                     form=\"dfa\",                     method=\"BFGS\",                     silent = TRUE ) # Plots states using all data plot(fit_MARSS, plot.type=\"xtT\") #> plot type = xtT Estimated states # Plot expectation for data using all data plot(fit_MARSS, plot.type=\"fitted.ytT\") #> plot type =  fitted.ytT  Observations with fitted values"},{"path":"/articles/dynamic_factor_analysis.html","id":"full-rank-covariance-using-dsem","dir":"Articles","previous_headings":"","what":"Full-rank covariance using DSEM","title":"Dynamic factor analysis","text":"DSEM syntax, can first fit saturated (full-covariance) model using argument covs: can define custom function plot states:  estimated states follow data closely smaller estimated confidence intervals. Presumably occurs using full-rank covariance far.","code":"# Add factors to data tsdata = ts( cbind(harborSealWA[,c(\"SJI\",\"EBays\",\"SJF\",\"PSnd\",\"HC\")]), start=1978)  # Scale and center (matches with MARSS does when fitting a DFA) tsdata = scale( tsdata, center=TRUE, scale=TRUE )  # Define SEM sem = \"   # Random-walk process for variables    SJF -> SJF, 1, NA, 1   SJI -> SJI, 1, NA, 1   EBays -> EBays, 1, NA, 1   PSnd -> PSnd, 1, NA, 1   HC -> HC, 1, NA, 1 \"  # Initial fit mydsem0 = dsem( tsdata = tsdata,                covs = c(\"SJF, SJI, EBays, PSnd, HC\"),                sem = sem,                family = rep(\"normal\", 5),                control = dsem_control( quiet = TRUE,                                        run_model = FALSE ) )    #> 1 regions found. #> Using 1 threads #> 1 regions found. #> Using 1 threads  # fix all measurement errors at diagonal and equal map = mydsem0$tmb_inputs$map map$lnsigma_j = factor( rep(1,ncol(tsdata)) )  # mydsem_full = dsem( tsdata = tsdata,                covs = c(\"SJF, SJI, EBays, PSnd, HC\"),                sem = sem,                family = rep(\"normal\", 5),                control = dsem_control( quiet = TRUE,                                        map = map ) ) #> 1 regions found. #> Using 1 threads #> 1 regions found. #> Using 1 threads plot_states = function( out,                         vars=1:ncol(out$tmb_inputs$data$y_tj) ){   #    xhat_tj = as.list(out$sdrep,report=TRUE,what=\"Estimate\")$z_tj[,vars,drop=FALSE]   xse_tj = as.list(out$sdrep,report=TRUE,what=\"Std. Error\")$z_tj[,vars,drop=FALSE]    #    longform = expand.grid( Year=time(tsdata), Var=colnames(tsdata)[vars] )   longform$est = as.vector(xhat_tj)   longform$se = as.vector(xse_tj)   longform$upper = longform$est + 1.96*longform$se   longform$lower = longform$est - 1.96*longform$se   longform$data = as.vector(tsdata[,vars,drop=FALSE])      #    ggplot(data=longform) +  #, aes(x=interaction(var,eq), y=Estimate, color=method)) +     geom_line( aes(x=Year,y=est) ) +     geom_point( aes(x=Year,y=data), color=\"blue\", na.rm=TRUE ) +     geom_ribbon( aes(ymax=as.numeric(upper),ymin=as.numeric(lower), x=Year), color=\"grey\", alpha=0.2 ) +      facet_wrap( facets=vars(Var), scales=\"free\", ncol=2 ) } plot_states( mydsem_full )"},{"path":"/articles/dynamic_factor_analysis.html","id":"reduced-rank-factor-model-with-measurement-errors","dir":"Articles","previous_headings":"","what":"Reduced-rank factor model with measurement errors","title":"Dynamic factor analysis","text":"Next, can specify two factors factors eliminating additional process error estimating measurement errors. requires us switch gmrf_parameterization = \"projection\", can fit rank-deficient Gaussian Markov random field: plot estimated latent variables  estimated predictor manifest variables  results similar (identical) factor values using MARSS DSEM. particular, DSEM higher variance early years. likely arises default MARSS implementation DFA includes penalty initial state ùê±0\\mathbf{x}_0 mean zero variance 5ùêà5\\mathbf{}. term presumably provides additional information initial year MARSS DFA results invariant reversing order data. explore, can modify MARSS DFA eliminate prior initial conditions, based help Dr.¬†Eli Holmes. involves specifying: estimated time-series similar DSEM  can now compare three options terms fitted log-likelihood: confirms MARSS model without penalty initial conditions results likelihood DSEM. Finally, can also compare three options terms estimated loadings: estimating loadings similar using DSEM MARSS model without initial penalty, except label switching (factors loadings can multiplied -1 change model):","code":"# Add factors to data tsdata = harborSealWA[,c(\"SJI\",\"EBays\",\"SJF\",\"PSnd\",\"HC\")] newcols = array( NA,                  dim = c(nrow(tsdata),n_factors),                  dimnames = list(NULL,paste0(\"F\",seq_len(n_factors))) ) tsdata = ts( cbind(tsdata, newcols), start=1978)  # Scale and center (matches with MARSS does when fitting a DFA) tsdata = scale( tsdata, center=TRUE, scale=TRUE )  # Automated version #sem = make_dfa( variables = c(\"SJI\",\"EBays\",\"SJF\",\"PSnd\",\"HC\"), #                n_factors = n_factors ) # Manual specification to show structure, using equations-and-lags interface equations = \"   # Loadings of variables onto factors   SJI = L11(0.1) * F1   EBays = L12(0.1) * F1 + L22(0.1) * F2   SJF = L13(0.1) * F1 + L23(0.1) * F2   PSnd = L14(0.1) * F1 + L24(0.1) * F2   HC = L15(0.1) * F1 + L25(0.1) * F2    # random walk for factors   F1 = NA(1) * lag[F1,1]   F2 = NA(1) * lag[F2,1]    # Unit variance for factors   V(F1) = NA(1)   V(F2) = NA(1)    # Zero residual variance for variables   V(SJI) = NA(0)   V(EBays) = NA(0)   V(SJF) = NA(0)   V(PSnd) = NA(0)   V(HC) = NA(0) \" sem = convert_equations(equations)  # Initial fit mydsem0 = dsem( tsdata = tsdata,                sem = sem,                family = c( rep(\"normal\",5), rep(\"fixed\",n_factors) ),                estimate_delta0 = TRUE,                control = dsem_control( quiet = TRUE,                                        run_model = FALSE,                                        gmrf_parameterization = \"projection\" ) )  # fix all measurement errors at diagonal and equal map = mydsem0$tmb_inputs$map map$lnsigma_j = factor( rep(1,ncol(tsdata)) )  # Fix factors to have initial value, and variables to not map$delta0_j = factor( c(rep(NA,ncol(harborSealWA)-1), 1:n_factors) )  # Fix variables to have no stationary mean except what's predicted by initial value map$mu_j = factor( rep(NA,ncol(tsdata)) )  # profile \"delta0_j\" to match MARSS (which treats initial condition as unpenalized random effect) mydfa = dsem( tsdata = tsdata,                sem = sem,                family = c( rep(\"normal\",5), rep(\"fixed\",n_factors) ),                estimate_delta0 = TRUE,                control = dsem_control( quiet = TRUE,                                        map = map,                                        use_REML = TRUE,                                        #profile = \"delta0_j\",                                        gmrf_parameterization = \"projection\" ) ) # Plot estimated factors plot_states( mydfa, vars=5+seq_len(n_factors) ) # Plot estimated variables plot_states( mydfa, vars=1:5 ) # Extract internal settings modmats <-  summary(fit_MARSS$model, silent=TRUE) #> Model Structure is #> m: 2 state process(es) #> n: 5 observation time series  # Redefine defaults modmats$V0 <- matrix(0, n_factors, n_factors ) modmats$x0 <- \"unequal\"   # Refit fit_MARSS2 = MARSS( dat,                      model = modmats,                     silent = TRUE,                     control = list( abstol = 0.001,                                     conv.test.slope.tol = 0.01,                                      maxit = 1000 )) # Plots states using all data plot(fit_MARSS2, plot.type=\"xtT\") #> plot type = xtT Estimated states # Compare likelihood for MARSS and DSEM Table = c( \"MARSS\" = logLik(fit_MARSS),             \"DSEM\" = logLik(mydfa),             \"MARSS_no_pen\" = logLik(fit_MARSS2) ) knitr::kable( Table, digits=3) Table = cbind( \"MARSS\" = as.vector(fit_MARSS$par$Z),        \"DSEM\" = grab(mydfa$opt$par,\"beta_z\"),        \"MARSS_no_pen\" = as.vector(fit_MARSS2$par$Z) ) rownames(Table) = names(fit_MARSS$coef)[1:nrow(Table)] knitr::kable( Table, digits=3)"},{"path":"/articles/vignette.html","id":"comparison-with-linear-models","dir":"Articles","previous_headings":"","what":"Comparison with linear models","title":"Demonstration of selected features","text":"first show dsem identical linear model. , simulate data single response single predictor: shows linear dynamic structural equation models give identical estimates single path coefficient. can also calculate leave-one-residuals display using DHARMa:  shows pattern quantile-quantile plot, expected given correctly specified model. can also confirm gives identical results linear model:","code":"# simulate normal distribution x = rnorm(100) y = 1 + 0.5 * x + rnorm(100) data = data.frame(x=x, y=y)  # Fit as linear model Lm = lm( y ~ x, data=data )  # Fit as DSEM fit = dsem( sem = \"x -> y, 0, beta\",             tsdata = ts(data),             control = dsem_control(quiet=TRUE) ) #> 1 regions found. #> Using 1 threads #> 1 regions found. #> Using 1 threads  # Display output m1 = rbind(   \"lm\" = summary(Lm)$coef[2,1:2],   \"dsem\" = summary(fit)[1,9:10] ) knitr::kable( m1, digits=3) # sample-based quantile residuals samples = loo_residuals(fit, what=\"samples\", track_progress=FALSE) which_use = which(!is.na(data)) fitResp = loo_residuals( fit, what=\"loo\", track_progress=FALSE)[,'est'] simResp = apply(samples, MARGIN=3, FUN=as.vector)[which_use,]  # Build and display DHARMa object res = DHARMa::createDHARMa(         simulatedResponse = simResp,         observedResponse = unlist(data)[which_use],         fittedPredictedResponse = fitResp ) plot(res) # Get DSEM Loo residuals and LM working residuals res = loo_residuals(fit, what=\"quantiles\", track_progress=FALSE) res0 = resid(Lm,\"working\")  # Plot comparison plot( x=res0, y=qnorm(res[,2]),       xlab=\"linear model residuals\", ylab=\"dsem residuals\" ) abline(a=0,b=1)"},{"path":"/articles/vignette.html","id":"comparison-with-dynamic-linear-models","dir":"Articles","previous_headings":"","what":"Comparison with dynamic linear models","title":"Demonstration of selected features","text":"next demonstrate dsem using well-known econometric model, Klein-1 model. model instead specified using equation--lag notation, makes model structure clear: first demonstrate dsem gives identical results dynlm:    Results show packages provide (almost) identical estimates standard errors. can also compare results using Laplace approximation obtained via numerical integration random effects using MCMC. example, MCMC results somewhat higher estimates exogenous variance parameters (presumably follow chi-squared distribution positive skewness), otherwise two produce similar estimates.","code":"data(KleinI, package=\"AER\") TS = ts(data.frame(KleinI, \"time\"=time(KleinI) - 1931))  # Specify by declaring each arrow and lag sem = \"   # Link, lag, param_name   cprofits -> consumption, 0, a1   cprofits -> consumption, 1, a2   pwage -> consumption, 0, a3   gwage -> consumption, 0, a3    cprofits -> invest, 0, b1   cprofits -> invest, 1, b2   capital -> invest, 0, b3    gnp -> pwage, 0, c2   gnp -> pwage, 1, c3   time -> pwage, 0, c1 \" tsdata = TS[,c(\"time\",\"gnp\",\"pwage\",\"cprofits\",'consumption',                \"gwage\",\"invest\",\"capital\")] fit = dsem( sem=sem,             tsdata = tsdata,             estimate_delta0 = TRUE,             control = dsem_control(               quiet = TRUE,               newton_loops = 0) ) # Specify using equations equations = \"   consumption = a1*cprofits + a2*lag[cprofits,1]+ a3*pwage + a3*gwage   invest = b1*cprofits + b2*lag[cprofits,1] + b3*capital   pwage = c1*time + c2*gnp + c3*lag[gnp,1] \"  # Convert and run sem = convert_equations(equations) fit = dsem( sem = sem,             tsdata = tsdata,             estimate_delta0 = TRUE,             control = dsem_control(               quiet = TRUE,               newton_loops = 0) ) # dynlm fm_cons <- dynlm(consumption ~ cprofits + L(cprofits) + I(pwage + gwage), data = TS) fm_inv <- dynlm(invest ~ cprofits + L(cprofits) + capital, data = TS) fm_pwage <- dynlm(pwage ~ gnp + L(gnp) + time, data = TS)  # Compile results m1 = rbind( summary(fm_cons)$coef[-1,],             summary(fm_inv)$coef[-1,],             summary(fm_pwage)$coef[-1,] )[,1:2] m2 = summary(fit$sdrep)[1:9,] m = rbind(   data.frame(\"var\"=rownames(m1),m1,\"method\"=\"OLS\",\"eq\"=rep(c(\"C\",\"I\",\"Wp\"),each=3)),   data.frame(\"var\"=rownames(m1),m2,\"method\"=\"GMRF\",\"eq\"=rep(c(\"C\",\"I\",\"Wp\"),each=3)) ) m = cbind(m, \"lower\"=m$Estimate-m$Std..Error, \"upper\"=m$Estimate+m$Std..Error )  # ggplot display of estimates longform = melt( as.data.frame(KleinI) )   longform$year = rep( time(KleinI), 9 ) p1 = ggplot( data=longform, aes(x=year, y=value) ) +   facet_grid( rows=vars(variable), scales=\"free\" ) +   geom_line( )  p2 = ggplot(data=m, aes(x=interaction(var,eq), y=Estimate, color=method)) +   geom_point( position=position_dodge(0.9) ) +   geom_errorbar( aes(ymax=as.numeric(upper),ymin=as.numeric(lower)),                  width=0.25, position=position_dodge(0.9))  #  p3 = plot( as_fitted_DAG(fit) ) +      expand_limits(x = c(-0.2,1) ) p4 = plot( as_fitted_DAG(fit, lag=1), text_size=4 ) +      expand_limits(x = c(-0.2,1), y = c(-0.2,0) )  p1 p2 grid.arrange( arrangeGrob(p3, p4, nrow=2) ) library(tmbstan)  # MCMC for both fixed and random effects mcmc = tmbstan( fit$obj, init=\"last.par.best\" ) summary_mcmc = summary(mcmc) # long-form data frame m1 = summary_mcmc$summary[1:17,c('mean','sd')] rownames(m1) = paste0( \"b\", seq_len(nrow(m1)) ) m2 = summary(fit$sdrep)[1:17,c('Estimate','Std. Error')] m = rbind(   data.frame('mean'=m1[,1], 'sd'=m1[,2], 'par'=rownames(m1), \"method\"=\"MCMC\"),   data.frame('mean'=m2[,1], 'sd'=m2[,2], 'par'=rownames(m1), \"method\"=\"LA\") ) m$lower = m$mean - m$sd m$upper = m$mean + m$sd  # plot ggplot(data=m, aes(x=par, y=mean, col=method)) +   geom_point( position=position_dodge(0.9) ) +   geom_errorbar( aes(ymax=as.numeric(upper),ymin=as.numeric(lower)),                  width=0.25, position=position_dodge(0.9))  #"},{"path":"/articles/vignette.html","id":"comparison-with-vector-autoregressive-models","dir":"Articles","previous_headings":"","what":"Comparison with vector autoregressive models","title":"Demonstration of selected features","text":"next demonstrate dsem gives similar results vector autoregressive (VAR) model. , analyze population abundance wolf moose populations Isle Royale 1959 2019, downloaded website (Vucetich, JA Peterson RO. 2012. population biology Isle Royale wolves moose: overview. URL: www.isleroyalewolf.org). dataset previously analyzed Chapter 14 User Manual R-package MARSS (Holmes, E. E., M. D. Scheuerell, E. J. Ward (2023) Analysis multivariate time-series using MARSS package. Version 3.11.8. NOAA Fisheries, Northwest Fisheries Science Center, 2725 Montlake Blvd E., Seattle, WA 98112, DOI: 10.5281/zenodo.5781847). , compare fits using dsem dynlm, well vector autoregressive model package vars, finally MARSS.  Results show dsem can estimate parameters vector autoregressive model (VAM), exactly matches results vars, using dynlm, using MARSS.","code":"data(isle_royale) data = ts( log(isle_royale[,2:3]), start=1959)  sem = \"   # Link, lag, param_name   wolves -> wolves, 1, arW   moose -> wolves, 1, MtoW   wolves -> moose, 1, WtoM   moose -> moose, 1, arM \" # initial first without delta0 (to improve starting values) fit0 = dsem( sem = sem,              tsdata = data,              estimate_delta0 = FALSE,              control = dsem_control(                quiet = FALSE,                getsd = FALSE) ) #>   Coefficient_name Number_of_coefficients   Type #> 1           beta_z                      6  Fixed #> 2             mu_j                      2 Random  # parameters = fit0$obj$env$parList()   parameters$delta0_j = rep( 0, ncol(data) )  # Refit with delta0 fit = dsem( sem = sem,             tsdata = data,             estimate_delta0 = TRUE,             control = dsem_control( quiet=TRUE,                                     parameters = parameters ) )  # dynlm fm_wolf = dynlm( wolves ~ 1 + L(wolves) + L(moose), data=data )   # fm_moose = dynlm( moose ~ 1 + L(wolves) + L(moose), data=data )   #  # MARSS library(MARSS) z.royale.dat <- t(scale(data.frame(data),center=TRUE,scale=FALSE)) royale.model.1 <- list(   Z = \"identity\",   B = \"unconstrained\",   Q = \"diagonal and unequal\",   R = \"zero\",   U = \"zero\" ) kem.1 <- MARSS(z.royale.dat, model = royale.model.1) #> Success! algorithm run for 15 iterations. abstol and log-log tests passed. #> Alert: conv.test.slope.tol is 0.5. #> Test with smaller values (<0.1) to ensure convergence. #>  #> MARSS fit is #> Estimation method: kem  #> Convergence test: conv.test.slope.tol = 0.5, abstol = 0.001 #> Algorithm ran 15 (=minit) iterations and convergence was reached.  #> Log-likelihood: -3.21765  #> AIC: 22.4353   AICc: 23.70964    #>   #>                       Estimate #> B.(1,1)                 0.8669 #> B.(2,1)                -0.1240 #> B.(1,2)                 0.1417 #> B.(2,2)                 0.8176 #> Q.(X.wolves,X.wolves)   0.1341 #> Q.(X.moose,X.moose)     0.0284 #> x0.X.wolves             0.2324 #> x0.X.moose             -0.6476 #> Initial states (x0) defined at t=0 #>  #> Standard errors have not been calculated.  #> Use MARSSparamCIs to compute CIs and bias estimates. SE <- MARSSparamCIs( kem.1 )  # Using VAR package library(vars) var = VAR( data, type=\"const\" )  ### Compile m1 = rbind( summary(fm_wolf)$coef[-1,], summary(fm_moose)$coef[-1,] )[,1:2] m2 = summary(fit$sdrep)[1:4,] #m2 = cbind( \"Estimate\"=fit$opt$par, \"Std. Error\"=fit$sdrep$par.fixed )[1:4,] m3 = cbind( SE$parMean[c(1,3,2,4)], SE$par.se$B[c(1,3,2,4)] ) colnames(m3) = colnames(m2) m4 = rbind( summary(var$varresult$wolves)$coef[-3,], summary(var$varresult$moose)$coef[-3,] )[,1:2]  # Bundle m = rbind(   data.frame(\"var\"=rownames(m1), m1, \"method\"=\"dynlm\", \"eq\"=rep(c(\"Wolf\",\"Moose\"),each=2)),   data.frame(\"var\"=rownames(m1), m2, \"method\"=\"dsem\", \"eq\"=rep(c(\"Wolf\",\"Moose\"),each=2)),   data.frame(\"var\"=rownames(m1), m3, \"method\"=\"MARSS\", \"eq\"=rep(c(\"Wolf\",\"Moose\"),each=2)),   data.frame(\"var\"=rownames(m1), m4, \"method\"=\"vars\", \"eq\"=rep(c(\"Wolf\",\"Moose\"),each=2)) ) #knitr::kable( m1, digits=3) #knitr::kable( m2, digits=3)  m = cbind(m, \"lower\"=m$Estimate-m$Std..Error, \"upper\"=m$Estimate+m$Std..Error )  # ggplot estimates ... interaction(x,y) causes an error sometimes library(ggplot2) library(ggpubr) library(ggraph) longform = reshape( isle_royale, idvar = \"year\", direction=\"long\", varying=list(2:3), v.names=\"abundance\", timevar=\"species\", times=c(\"wolves\",\"moose\") ) p1 = ggplot( data=longform, aes(x=year, y=abundance) ) +   facet_grid( rows=vars(species), scales=\"free\" ) +   geom_point( )  p2 = ggplot(data=m, aes(x=interaction(var,eq), y=Estimate, color=method)) +   geom_point( position=position_dodge(0.9) ) +   geom_errorbar( aes(ymax=as.numeric(upper),ymin=as.numeric(lower)),                  width=0.25, position=position_dodge(0.9))  # p3 = plot( as_fitted_DAG(fit, lag=1), rotation=0 ) +      geom_edge_loop( aes( label=round(weight,2), direction=0)) + #arrow=arrow(), , angle_calc=\"along\", label_dodge=grid::unit(10,\"points\") )      expand_limits(x = c(-0.1,0) )  ggarrange( p1, p2, p3,            labels = c(\"Time-series data\", \"Estimated effects\", \"Fitted path digram\"),            ncol = 1, nrow = 3)"},{"path":"/articles/vignette.html","id":"multi-causal-ecosystem-synthesis","dir":"Articles","previous_headings":"","what":"Multi-causal ecosystem synthesis","title":"Demonstration of selected features","text":"next replicate analysis involving climate, forage fishes, stomach contents, recruitment predatory fish.   results discussed paper describing dsem.","code":"data(bering_sea) Z = ts( bering_sea ) family = rep('fixed', ncol(bering_sea))  # Specify model sem = \"   # Link, lag, param_name   log_seaice -> log_CP, 0, seaice_to_CP   log_CP -> log_Cfall, 0, CP_to_Cfall   log_CP -> log_Esummer, 0, CP_to_E   log_PercentEuph -> log_RperS, 0, Seuph_to_RperS   log_PercentCop -> log_RperS, 0, Scop_to_RperS   log_Esummer -> log_PercentEuph, 0, Esummer_to_Suph   log_Cfall -> log_PercentCop, 0, Cfall_to_Scop   SSB -> log_RperS, 0, SSB_to_RperS    log_seaice -> log_seaice, 1, AR1, 0.001   log_CP -> log_CP, 1,  AR2, 0.001   log_Cfall -> log_Cfall, 1, AR4, 0.001   log_Esummer -> log_Esummer, 1, AR5, 0.001   SSB -> SSB, 1, AR6, 0.001   log_RperS ->  log_RperS, 1, AR7, 0.001   log_PercentEuph -> log_PercentEuph, 1, AR8, 0.001   log_PercentCop -> log_PercentCop, 1, AR9, 0.001 \"  # Fit fit = dsem( sem = sem,             tsdata = Z,             family = family,             control = dsem_control(use_REML=FALSE, quiet=TRUE) ) ParHat = fit$obj$env$parList() # summary( fit ) # Timeseries plot oldpar <- par(no.readonly = TRUE) par( mfcol=c(3,3), mar=c(2,2,2,0), mgp=c(2,0.5,0), tck=-0.02 ) for(i in 1:ncol(bering_sea)){   tmp = bering_sea[,i,drop=FALSE]   tmp = cbind( tmp, \"pred\"=ParHat$x_tj[,i] )   SD = as.list(fit$sdrep,what=\"Std.\")$x_tj[,i]   tmp = cbind( tmp, \"lower\"=tmp[,2] - ifelse(is.na(SD),0,SD),                     \"upper\"=tmp[,2] + ifelse(is.na(SD),0,SD) )   #   plot( x=rownames(bering_sea), y=tmp[,1], ylim=range(tmp,na.rm=TRUE),         type=\"p\", main=colnames(bering_sea)[i], pch=20, cex=2 )   lines( x=rownames(bering_sea), y=tmp[,2], type=\"l\", lwd=2,          col=\"blue\", lty=\"solid\" )   polygon( x=c(rownames(bering_sea),rev(rownames(bering_sea))),            y=c(tmp[,3],rev(tmp[,4])), col=rgb(0,0,1,0.2), border=NA ) } par(oldpar) # library(phylopath) library(ggplot2) library(ggpubr) library(reshape) library(gridExtra) longform = melt( bering_sea )   longform$year = rep( 1963:2023, ncol(bering_sea) ) p0 = ggplot( data=longform, aes(x=year, y=value) ) +   facet_grid( rows=vars(variable), scales=\"free\" ) +   geom_point( )  p1 = plot( (as_fitted_DAG(fit)), edge.width=1, type=\"width\",            text_size=4, show.legend=FALSE,            arrow = grid::arrow(type='closed', 18, grid::unit(10,'points')) ) +      scale_x_continuous(expand = c(0.4, 0.1)) p1$layers[[1]]$mapping$edge_width = 1 p2 = plot( (as_fitted_DAG(fit, what=\"p_value\")), edge.width=1, type=\"width\",            text_size=4, show.legend=FALSE, colors=c('black', 'black'),            arrow = grid::arrow(type='closed', 18, grid::unit(10,'points')) ) +      scale_x_continuous(expand = c(0.4, 0.1)) p2$layers[[1]]$mapping$edge_width = 0.5  #grid.arrange( arrangeGrob( p0+ggtitle(\"timeseries\"), #              arrangeGrob( p1+ggtitle(\"Estimated path diagram\"), #                           p2+ggtitle(\"Estimated p-values\"), nrow=2), ncol=2 ) ) ggarrange(p1, p2, labels = c(\"Simultaneous effects\", \"Two-sided p-value\"),                     ncol = 1, nrow = 2)"},{"path":"/articles/vignette.html","id":"site-replicated-trophic-cascade","dir":"Articles","previous_headings":"","what":"Site-replicated trophic cascade","title":"Demonstration of selected features","text":"Finally, replicate analysis involving trophic cascade involving sea stars predators, sea urchin consumers, kelp producers.  , results discussed paper describing dsem.","code":"data(sea_otter) Z = ts( sea_otter[,-1] )  # Specify model sem = \"   Pycno_CANNERY_DC -> log_Urchins_CANNERY_DC, 0, x2   log_Urchins_CANNERY_DC -> log_Kelp_CANNERY_DC, 0, x3   log_Otter_Count_CANNERY_DC -> log_Kelp_CANNERY_DC, 0, x4    Pycno_CANNERY_UC -> log_Urchins_CANNERY_UC, 0, x2   log_Urchins_CANNERY_UC -> log_Kelp_CANNERY_UC, 0, x3   log_Otter_Count_CANNERY_UC -> log_Kelp_CANNERY_UC, 0, x4    Pycno_HOPKINS_DC -> log_Urchins_HOPKINS_DC, 0, x2   log_Urchins_HOPKINS_DC -> log_Kelp_HOPKINS_DC, 0, x3   log_Otter_Count_HOPKINS_DC -> log_Kelp_HOPKINS_DC, 0, x4    Pycno_HOPKINS_UC -> log_Urchins_HOPKINS_UC, 0, x2   log_Urchins_HOPKINS_UC -> log_Kelp_HOPKINS_UC, 0, x3   log_Otter_Count_HOPKINS_UC -> log_Kelp_HOPKINS_UC, 0, x4    Pycno_LOVERS_DC -> log_Urchins_LOVERS_DC, 0, x2   log_Urchins_LOVERS_DC -> log_Kelp_LOVERS_DC, 0, x3   log_Otter_Count_LOVERS_DC -> log_Kelp_LOVERS_DC, 0, x4    Pycno_LOVERS_UC -> log_Urchins_LOVERS_UC, 0, x2   log_Urchins_LOVERS_UC -> log_Kelp_LOVERS_UC, 0, x3   log_Otter_Count_LOVERS_UC -> log_Kelp_LOVERS_UC, 0, x4    Pycno_MACABEE_DC -> log_Urchins_MACABEE_DC, 0, x2   log_Urchins_MACABEE_DC -> log_Kelp_MACABEE_DC, 0, x3   log_Otter_Count_MACABEE_DC -> log_Kelp_MACABEE_DC, 0, x4    Pycno_MACABEE_UC -> log_Urchins_MACABEE_UC, 0, x2   log_Urchins_MACABEE_UC -> log_Kelp_MACABEE_UC, 0, x3   log_Otter_Count_MACABEE_UC -> log_Kelp_MACABEE_UC, 0, x4    Pycno_OTTER_PT_DC -> log_Urchins_OTTER_PT_DC, 0, x2   log_Urchins_OTTER_PT_DC -> log_Kelp_OTTER_PT_DC, 0, x3   log_Otter_Count_OTTER_PT_DC -> log_Kelp_OTTER_PT_DC, 0, x4    Pycno_OTTER_PT_UC -> log_Urchins_OTTER_PT_UC, 0, x2   log_Urchins_OTTER_PT_UC -> log_Kelp_OTTER_PT_UC, 0, x3   log_Otter_Count_OTTER_PT_UC -> log_Kelp_OTTER_PT_UC, 0, x4    Pycno_PINOS_CEN -> log_Urchins_PINOS_CEN, 0, x2   log_Urchins_PINOS_CEN -> log_Kelp_PINOS_CEN, 0, x3   log_Otter_Count_PINOS_CEN -> log_Kelp_PINOS_CEN, 0, x4    Pycno_SIREN_CEN -> log_Urchins_SIREN_CEN, 0, x2   log_Urchins_SIREN_CEN -> log_Kelp_SIREN_CEN, 0, x3   log_Otter_Count_SIREN_CEN -> log_Kelp_SIREN_CEN, 0, x4    # AR1   Pycno_CANNERY_DC -> Pycno_CANNERY_DC, 1, ar1   log_Urchins_CANNERY_DC -> log_Urchins_CANNERY_DC, 1, ar2   log_Otter_Count_CANNERY_DC -> log_Otter_Count_CANNERY_DC, 1, ar3   log_Kelp_CANNERY_DC -> log_Kelp_CANNERY_DC, 1, ar4    Pycno_CANNERY_UC -> Pycno_CANNERY_UC, 1, ar1   log_Urchins_CANNERY_UC -> log_Urchins_CANNERY_UC, 1, ar2   log_Otter_Count_CANNERY_UC -> log_Otter_Count_CANNERY_UC, 1, ar3   log_Kelp_CANNERY_UC -> log_Kelp_CANNERY_UC, 1, ar4    Pycno_HOPKINS_DC -> Pycno_HOPKINS_DC, 1, ar1   log_Urchins_HOPKINS_DC -> log_Urchins_HOPKINS_DC, 1, ar2   log_Otter_Count_HOPKINS_DC -> log_Otter_Count_HOPKINS_DC, 1, ar3   log_Kelp_HOPKINS_DC -> log_Kelp_HOPKINS_DC, 1, ar4    Pycno_HOPKINS_UC -> Pycno_HOPKINS_UC, 1, ar1   log_Urchins_HOPKINS_UC -> log_Urchins_HOPKINS_UC, 1, ar2   log_Otter_Count_HOPKINS_UC -> log_Otter_Count_HOPKINS_UC, 1, ar3   log_Kelp_HOPKINS_UC -> log_Kelp_HOPKINS_UC, 1, ar4    Pycno_LOVERS_DC -> Pycno_LOVERS_DC, 1, ar1   log_Urchins_LOVERS_DC -> log_Urchins_LOVERS_DC, 1, ar2   log_Otter_Count_LOVERS_DC -> log_Otter_Count_LOVERS_DC, 1, ar3   log_Kelp_LOVERS_DC -> log_Kelp_LOVERS_DC, 1, ar4    Pycno_LOVERS_UC -> Pycno_LOVERS_UC, 1, ar1   log_Urchins_LOVERS_UC -> log_Urchins_LOVERS_UC, 1, ar2   log_Otter_Count_LOVERS_UC -> log_Otter_Count_LOVERS_UC, 1, ar3   log_Kelp_LOVERS_UC -> log_Kelp_LOVERS_UC, 1, ar4    Pycno_MACABEE_DC -> Pycno_MACABEE_DC, 1, ar1   log_Urchins_MACABEE_DC -> log_Urchins_MACABEE_DC, 1, ar2   log_Otter_Count_MACABEE_DC -> log_Otter_Count_MACABEE_DC, 1, ar3   log_Kelp_MACABEE_DC -> log_Kelp_MACABEE_DC, 1, ar4    Pycno_MACABEE_UC -> Pycno_MACABEE_UC, 1, ar1   log_Urchins_MACABEE_UC -> log_Urchins_MACABEE_UC, 1, ar2   log_Otter_Count_MACABEE_UC -> log_Otter_Count_MACABEE_UC, 1, ar3   log_Kelp_MACABEE_UC -> log_Kelp_MACABEE_UC, 1, ar4    Pycno_OTTER_PT_DC -> Pycno_OTTER_PT_DC, 1, ar1   log_Urchins_OTTER_PT_DC -> log_Urchins_OTTER_PT_DC, 1, ar2   log_Otter_Count_OTTER_PT_DC -> log_Otter_Count_OTTER_PT_DC, 1, ar3   log_Kelp_OTTER_PT_DC -> log_Kelp_OTTER_PT_DC, 1, ar4    Pycno_OTTER_PT_UC -> Pycno_OTTER_PT_UC, 1, ar1   log_Urchins_OTTER_PT_UC -> log_Urchins_OTTER_PT_UC, 1, ar2   log_Otter_Count_OTTER_PT_UC -> log_Otter_Count_OTTER_PT_UC, 1, ar3   log_Kelp_OTTER_PT_UC -> log_Kelp_OTTER_PT_UC, 1, ar4    Pycno_PINOS_CEN -> Pycno_PINOS_CEN, 1, ar1   log_Urchins_PINOS_CEN -> log_Urchins_PINOS_CEN, 1, ar2   log_Otter_Count_PINOS_CEN -> log_Otter_Count_PINOS_CEN, 1, ar3   log_Kelp_PINOS_CEN -> log_Kelp_PINOS_CEN, 1, ar4    Pycno_SIREN_CEN -> Pycno_SIREN_CEN, 1, ar1   log_Urchins_SIREN_CEN -> log_Urchins_SIREN_CEN, 1, ar2   log_Otter_Count_SIREN_CEN -> log_Otter_Count_SIREN_CEN, 1, ar3   log_Kelp_SIREN_CEN -> log_Kelp_SIREN_CEN, 1, ar4 \"  # Fit model fit = dsem( sem = sem,             tsdata = Z,             control = dsem_control(use_REML=FALSE, quiet=TRUE) ) # summary( fit )  # library(phylopath) library(ggplot2) library(ggpubr) get_part = function(x){   vars = c(\"log_Kelp\",\"log_Otter\",\"log_Urchin\",\"Pycno\")   index = sapply( vars, FUN=\\(y) grep(y,rownames(x$coef))[1] )   x$coef = x$coef[index,index]   dimnames(x$coef) = list( vars, vars )   return(x) } p1 = plot( get_part(as_fitted_DAG(fit)), type=\"width\", show.legend=FALSE) p1$layers[[1]]$mapping$edge_width = 0.5 p2 = plot( get_part(as_fitted_DAG(fit, what=\"p_value\" )), type=\"width\",            show.legend=FALSE, colors=c('black', 'black')) p2$layers[[1]]$mapping$edge_width = 0.1  longform = melt( sea_otter[,-1], as.is=TRUE ) longform$X1 = 1999:2019[longform$X1] longform$Site = gsub( \"log_Kelp_\", \"\",                 gsub( \"log_Urchins_\", \"\",                 gsub( \"Pycno_\", \"\",                 gsub( \"log_Otter_Count_\", \"\", longform$X2)))) longform$Species = sapply( seq_len(nrow(longform)), FUN=\\(i)gsub(longform$Site[i],\"\",longform$X2[i]) ) p3 = ggplot( data=longform, aes(x=X1, y=value, col=Species) ) +   facet_grid( rows=vars(Site), scales=\"free\" ) +   geom_line( )  ggarrange(p1 + scale_x_continuous(expand = c(0.3, 0)),                     p2 + scale_x_continuous(expand = c(0.3, 0)),                     labels = c(\"Simultaneous effects\", \"Two-sided p-value\"),                     ncol = 1, nrow = 2)"},{"path":"/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"James Thorson. Author, maintainer.","code":""},{"path":"/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Thorson, J. T., Andrews, . G., Essington, T., & Large, S. (2024). Dynamic structural equation models synthesize ecosystem dynamics constrained ecological mechanisms. Methods Ecology Evolution 15(4): 744-755. https://doi.org/10.1111/2041-210X.14289","code":"@Article{,   title = {Dynamic structural equation models synthesize ecosystem dynamics constrained by ecological mechanisms},   journal = {Methods in Ecology and Evolution},   volume = {15},   number = {4},   pages = {744-755},   year = {2024},   doi = {10.1111/2041-210X.14289},   url = {https://doi.org/10.1111/2041-210X.14289},   author = {J. T. Thorson and A. G. Andrews and T. Essington and S. Large}, }"},{"path":"/index.html","id":"dynamic-structural-equation-models","dir":"","previous_headings":"","what":"Dynamic structural equation models","title":"Fit Dynamic Structural Equation Models","text":"Package dsem fits dynamic structural equation models, includes nested submodels: structural equation models vector autoregressive models dynamic factor analysis state-space autoregressive integrated moving average (ARIMA) models model several advantages: estimates direct, indirect, total effects among system variables, including simultaneous lagged effects recursive (cyclic) dependencies can estimate cumulative outcome press pulse experiments initial conditions differ stationary distribution system dynamics estimates structural linkages regression slopes jointly imputing missing values /measurement errors rapidly fitted Gaussian Markov random field (GMRF) Generalized Linear Mixed Model (GLMM), speed asymptotics associated allows granular control number parameters (restrictions parameters) used structure covariance among variables time, dsem specifically intended minimal implementation, uses standard packages simplify input/output formatting: Input: time-series defined using class ts, NA missing values Input: structural trade-offs specified using syntax defined package sem Output: visualizing estimated trade-offs using igraph Output: access model output using standard S3-generic functions including summary, predict, residuals, simulate, AIC Please see package vignettes details regarding syntax features.","code":""},{"path":"/reference/TMBAIC.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate marginal AIC for a fitted model ‚Äî TMBAIC","title":"Calculate marginal AIC for a fitted model ‚Äî TMBAIC","text":"TMBAIC calculates AIC given model fit","code":""},{"path":"/reference/TMBAIC.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate marginal AIC for a fitted model ‚Äî TMBAIC","text":"","code":"TMBAIC(opt, k = 2, n = Inf)"},{"path":"/reference/TMBAIC.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate marginal AIC for a fitted model ‚Äî TMBAIC","text":"opt output nlminb optim k penalty additional fixed effects (default=2, AIC) n sample size, use AICc calculation (default=Inf, AICc=AIC)","code":""},{"path":"/reference/TMBAIC.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate marginal AIC for a fitted model ‚Äî TMBAIC","text":"AIC, parsimonious model AIC relative candidate models","code":""},{"path":"/reference/as_fitted_DAG.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert output from package dsem to phylopath ‚Äî as_fitted_DAG","title":"Convert output from package dsem to phylopath ‚Äî as_fitted_DAG","text":"Convert dsem phylopath output","code":""},{"path":"/reference/as_fitted_DAG.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert output from package dsem to phylopath ‚Äî as_fitted_DAG","text":"","code":"as_fitted_DAG(   fit,   lag = 0,   what = c(\"Estimate\", \"Std_Error\", \"p_value\"),   direction = 1 )"},{"path":"/reference/as_fitted_DAG.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert output from package dsem to phylopath ‚Äî as_fitted_DAG","text":"fit Output dsem lag lag output whether output estimates =\"Estimate\", standard errors =\"Std_Error\" p-values =\"Std_Error\" direction whether include one-sided arrows direction=1, one- two-sided arrows direction=c(1,2)","code":""},{"path":"/reference/as_fitted_DAG.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert output from package dsem to phylopath ‚Äî as_fitted_DAG","text":"Convert output format supplied est_DAG","code":""},{"path":"/reference/as_sem.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert dsem to sem output ‚Äî as_sem","title":"Convert dsem to sem output ‚Äî as_sem","text":"Convert output package dsem sem","code":""},{"path":"/reference/as_sem.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert dsem to sem output ‚Äî as_sem","text":"","code":"as_sem(object, lag = 0)"},{"path":"/reference/as_sem.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert dsem to sem output ‚Äî as_sem","text":"object Output dsem lag lag extract visualize","code":""},{"path":"/reference/as_sem.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert dsem to sem output ‚Äî as_sem","text":"Convert output format supplied sem","code":""},{"path":"/reference/bering_sea.html","id":null,"dir":"Reference","previous_headings":"","what":"Bering Sea marine ecosystem ‚Äî bering_sea","title":"Bering Sea marine ecosystem ‚Äî bering_sea","text":"Data used demonstrate test ecosystem synthesis","code":""},{"path":"/reference/bering_sea.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Bering Sea marine ecosystem ‚Äî bering_sea","text":"","code":"data(bering_sea)"},{"path":"/reference/classify_variables.html","id":null,"dir":"Reference","previous_headings":"","what":"Classify variables path ‚Äî classify_variables","title":"Classify variables path ‚Äî classify_variables","text":"classify_variables copied sem:::classifyVariables","code":""},{"path":"/reference/classify_variables.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Classify variables path ‚Äî classify_variables","text":"","code":"classify_variables(model)"},{"path":"/reference/classify_variables.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Classify variables path ‚Äî classify_variables","text":"model SEM model","code":""},{"path":"/reference/classify_variables.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Classify variables path ‚Äî classify_variables","text":"Tagged-list defining exogenous endogenous variables","code":""},{"path":"/reference/classify_variables.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Classify variables path ‚Äî classify_variables","text":"Copied package `sem` licence GPL (>= 2) permission John Fox","code":""},{"path":"/reference/convert_equations.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert equations notation ‚Äî convert_equations","title":"Convert equations notation ‚Äî convert_equations","text":"Converts equations arrow--lag notation expected dsem","code":""},{"path":"/reference/convert_equations.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert equations notation ‚Äî convert_equations","text":"","code":"convert_equations(equations)"},{"path":"/reference/convert_equations.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert equations notation ‚Äî convert_equations","text":"equations Specification time-series structural equation model structure including lagged simultaneous effects.  See Details section equations_to_text description","code":""},{"path":"/reference/convert_equations.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Convert equations notation ‚Äî convert_equations","text":"function modifies code copied package `sem` licence GPL (>= 2) permission John Fox. specifyEquations, input line either regression equation specification variance covariance. Regression equations form y = par1*x1 + par2*x2 + ... + park*xk y xs variables model (either observed latent), pars parameters. parameter given numeric value (e.g., 1) treated fixed. Note error variable included equation; error variances specified via either covs argument, via V(y) = par (see immediately ), added automatically model , default, endog.variances=TRUE. regression equation may split one input breaking +, + either last non-blank character line first non-blank character subsequent line. Variances specified form V(var) = par covariances form C(var1, var2) = par, vars variables (observed unobserved) model. symbols V C may either lower- upper-case. par numeric value (e.g., 1) treated fixed. conformity RAM model, variance covariance endogenous variable model error variance covariance. set start value free parameter, enclose numeric start value parentheses parameter name, parameter(value).","code":""},{"path":"/reference/dsem.html","id":null,"dir":"Reference","previous_headings":"","what":"Fit dynamic structural equation model ‚Äî dsem","title":"Fit dynamic structural equation model ‚Äî dsem","text":"Fits dynamic structural equation model","code":""},{"path":"/reference/dsem.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fit dynamic structural equation model ‚Äî dsem","text":"","code":"dsem(   sem,   tsdata,   family = rep(\"fixed\", ncol(tsdata)),   estimate_delta0 = FALSE,   control = dsem_control(),   covs = colnames(tsdata) )"},{"path":"/reference/dsem.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fit dynamic structural equation model ‚Äî dsem","text":"sem Specification time-series structural equation model structure including lagged simultaneous effects.  See Details section make_dsem_ram description tsdata time-series data, outputted using ts family Character-vector listing distribution used column tsdata, element must fixed normal. family=\"fixed\" default behavior assumes given variable measured exactly. options correspond different specifications measurement error. estimate_delta0 Boolean indicating whether estimate deviations equilibrium initial year fixed effects, alternatively assume dynamics start stochastic draw away stationary distribution control Output dsem_control, used define user settings, see documentation function details. covs optional: character vector one elements, element giving string variable names, separated commas. Variances covariances among variables string added model. Warning: covs=\"x1, x2\" covs=c(\"x1\", \"x2\") equivalent: covs=\"x1, x2\" specifies variance x1, variance x2, covariance, covs=c(\"x1\", \"x2\") specifies variance x1 variance x2 covariance. covariances can added manually via argument `sem`, using argument `covs` might save time models many variables.","code":""},{"path":"/reference/dsem.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fit dynamic structural equation model ‚Äî dsem","text":"object (list) class `dsem`. Elements include: obj TMB object MakeADFun ram RAM parsed make_dsem_ram model SEM structure parsed make_dsem_ram intermediate description model linkages tmb_inputs list inputs passed MakeADFun opt output nlminb sdrep output sdreport interal Objects useful package function, .e., arguments                passed call","code":""},{"path":"/reference/dsem.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Fit dynamic structural equation model ‚Äî dsem","text":"DSEM involves (minimum): Time series matrix \\(\\mathbf X\\) column \\(\\mathbf x_c\\) variable c         time-series; Path diagram user-supplied specification path coefficients,         define precision (inverse covariance) \\(\\mathbf Q\\) matrix state-variables         see make_dsem_ram details math involved. model also estimates time-series mean \\( \\mathbf{\\mu}_c \\) variable. mean precision matrix therefore define Gaussian Markov random field \\(\\mathbf X\\): $$ \\mathrm{vec}(\\mathbf X) \\sim \\mathrm{MVN}( \\mathrm{vec}(\\mathbf{I_T} \\otimes \\mathbf{\\mu}), \\mathbf{Q}^{-1}) $$ Users can specify distribution measurement errors (assume variables measured without error) using argument family.  defines link-function \\(g_c(.)\\) distribution \\(f_c(.)\\) time-series \\(c\\): $$ y_{t,c} \\sim f_c( g_c^{-1}( x_{t,c} ), \\theta_c )$$ dsem estimates specified coefficients, time-series means \\(\\mu_c\\), distribution measurement errors \\(\\theta_c\\) via maximizing log-marginal likelihood, also estimating state-variables \\(x_{t,c}\\). summary.dsem assembles estimates standard errors easy--read format. Standard errors fixed effects (path coefficients, exogenoux variance parameters, measurement error parameters) estimated matrix second derivatives log-marginal likelihod, standard errors random effects (.e., missing state-space variables) estimated generalization method (see sdreport details).","code":""},{"path":"/reference/dsem.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Fit dynamic structural equation model ‚Äî dsem","text":"**Introducing package, features, comparison software (cite using dsem):** Thorson, J. T., Andrews, ., Essington, T., Large, S. (review). Dynamic structural equation models synthesize ecosystem dynamics constrained ecological mechanisms.","code":""},{"path":"/reference/dsem.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fit dynamic structural equation model ‚Äî dsem","text":"","code":"# Define model sem = \"   # Link, lag, param_name   cprofits -> consumption, 0, a1   cprofits -> consumption, 1, a2   pwage -> consumption, 0, a3   gwage -> consumption, 0, a3   cprofits -> invest, 0, b1   cprofits -> invest, 1, b2   capital -> invest, 0, b3   gnp -> pwage, 0, c2   gnp -> pwage, 1, c3   time -> pwage, 0, c1 \"  # Load data data(KleinI, package=\"AER\") TS = ts(data.frame(KleinI, \"time\"=time(KleinI) - 1931)) tsdata = TS[,c(\"time\",\"gnp\",\"pwage\",\"cprofits\",'consumption',                \"gwage\",\"invest\",\"capital\")]  # Fit model fit = dsem( sem=sem,             tsdata = tsdata,             estimate_delta0 = TRUE,             control = dsem_control(quiet=TRUE) ) #> 1 regions found. #> Using 1 threads #> 1 regions found. #> Using 1 threads summary( fit ) #>                           path lag           name start parameter       first #> 1      cprofits -> consumption   0             a1  <NA>         1    cprofits #> 2      cprofits -> consumption   1             a2  <NA>         2    cprofits #> 3         pwage -> consumption   0             a3  <NA>         3       pwage #> 4         gwage -> consumption   0             a3  <NA>         3       gwage #> 5           cprofits -> invest   0             b1  <NA>         4    cprofits #> 6           cprofits -> invest   1             b2  <NA>         5    cprofits #> 7            capital -> invest   0             b3  <NA>         6     capital #> 8                 gnp -> pwage   0             c2  <NA>         7         gnp #> 9                 gnp -> pwage   1             c3  <NA>         8         gnp #> 10               time -> pwage   0             c1  <NA>         9        time #> 11               time <-> time   0        V[time]  <NA>        10        time #> 12                 gnp <-> gnp   0         V[gnp]  <NA>        11         gnp #> 13             pwage <-> pwage   0       V[pwage]  <NA>        12       pwage #> 14       cprofits <-> cprofits   0    V[cprofits]  <NA>        13    cprofits #> 15 consumption <-> consumption   0 V[consumption]  <NA>        14 consumption #> 16             gwage <-> gwage   0       V[gwage]  <NA>        15       gwage #> 17           invest <-> invest   0      V[invest]  <NA>        16      invest #> 18         capital <-> capital   0     V[capital]  <NA>        17     capital #>         second direction    Estimate  Std_Error   z_value       p_value #> 1  consumption         1  0.19323185 0.08199229  2.356708  1.843776e-02 #> 2  consumption         1  0.08942112 0.08136334  1.099035  2.717530e-01 #> 3  consumption         1  0.79625663 0.03594118 22.154439 9.452934e-109 #> 4  consumption         1  0.79625663 0.03594118 22.154439 9.452934e-109 #> 5       invest         1  0.48138141 0.08740019  5.507785  3.633777e-08 #> 6       invest         1  0.33084616 0.09069261  3.647995  2.642950e-04 #> 7       invest         1 -0.11150752 0.02408258 -4.630214  3.652875e-06 #> 8        pwage         1  0.44041577 0.02921824 15.073314  2.426312e-51 #> 9        pwage         1  0.14476511 0.03370693  4.294817  1.748376e-05 #> 10       pwage         1  0.13029837 0.02882711  4.519995  6.184119e-06 #> 11        time         2  6.05530071 0.93435313  6.480741  9.127318e-11 #> 12         gnp         2 10.32020497 1.58102475  6.527542  6.685791e-11 #> 13       pwage         2  0.69302930 0.10701058  6.476269  9.401826e-11 #> 14    cprofits         2  4.10929046 0.63141034  6.508114  7.610017e-11 #> 15 consumption         2  0.92285232 0.14239896  6.480752  9.126683e-11 #> 16       gwage         2  1.90952975 0.29464666  6.480745  9.127100e-11 #> 17      invest         2  0.91015034 0.14046563  6.479523  9.201284e-11 #> 18     capital         2  9.67950590 1.49358015  6.480741  9.127332e-11 plot( fit )  plot( fit, edge_label=\"value\" )"},{"path":"/reference/dsem_control.html","id":null,"dir":"Reference","previous_headings":"","what":"Detailed control for dsem structure ‚Äî dsem_control","title":"Detailed control for dsem structure ‚Äî dsem_control","text":"Define list control parameters.  Note format input likely change rapidly dsem","code":""},{"path":"/reference/dsem_control.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Detailed control for dsem structure ‚Äî dsem_control","text":"","code":"dsem_control(   nlminb_loops = 1,   newton_loops = 1,   trace = 0,   eval.max = 1000,   iter.max = 1000,   getsd = TRUE,   quiet = FALSE,   run_model = TRUE,   gmrf_parameterization = c(\"separable\", \"projection\"),   constant_variance = c(\"conditional\", \"marginal\", \"diagonal\"),   use_REML = TRUE,   profile = NULL,   parameters = NULL,   map = NULL,   getJointPrecision = FALSE,   extra_convergence_checks = TRUE,   lower = -Inf,   upper = Inf )"},{"path":"/reference/dsem_control.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Detailed control for dsem structure ‚Äî dsem_control","text":"nlminb_loops Integer number times call nlminb. newton_loops Integer number Newton steps running nlminb. trace Parameter values printed every `trace` iteration outer optimizer. Passed `control` nlminb. eval.max Maximum number evaluations objective function allowed. Passed `control` nlminb. iter.max Maximum number iterations allowed. Passed `control` nlminb. getsd Boolean indicating whether call sdreport quiet Boolean indicating whether run model printing messages terminal ; run_model Boolean indicating whether estimate parameters (default), instead return model inputs compiled TMB object without running; gmrf_parameterization Parameterization use Gaussian Markov random field, default `separable` constructs precision matrix must full rank, alternative `projection` constructs full-rank IID precision variables time, projects using inverse-cholesky precision, projection can rank-deficient. constant_variance Whether specify constant conditional variance \\( \\mathbf{\\Gamma \\Gamma}^t\\) using default constant_variance=\"conditional\", results changing marginal variance along specified causal graph lagged paths present. Alternatively, user can specify constant marginal variance using constant_variance=\"diagonal\" constant_variance=\"marginal\", \\( \\mathbf{\\Gamma}\\) \\(\\mathbf{-P}\\) rescaled achieve constraint. options equivalent model includes lags (simultaneous effects) covariances (two-headed arrows).  \"diagonal\" \"marginal\" equivalent model includes covariances. Given exogenous covariance, constant_variance = \"diagonal\" preserves conditional correlation changing conditional variance, constant_variance = \"marginal\" changing conditional correlation along causal graph. use_REML Boolean indicating whether treat non-variance fixed effects random, either motigate bias estimated variance parameters improve efficiency parameter estimation given correlated fixed random effects profile Parameters profile likelihood (subset appended random Laplace approximation disabled). parameters list fixed random effects, e.g., constructed dsem modified hand (helpful advanced users change starting values restart intended values) map list fixed mirrored parameters, constructed dsem default available override default pass MakeADFun getJointPrecision whether get joint precision matrix.  Passed sdreport. extra_convergence_checks Boolean indicating whether run extra checks model convergence. lower vectors lower bounds, replicated long start passed nlminb. unspecified, parameters assumed unconstrained. upper vectors upper bounds, replicated long start passed nlminb. unspecified, parameters assumed unconstrained.","code":""},{"path":"/reference/dsem_control.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Detailed control for dsem structure ‚Äî dsem_control","text":"S3 object class \"dsem_control\" specifies detailed model settings, allowing user specification also specifying default values","code":""},{"path":"/reference/isle_royale.html","id":null,"dir":"Reference","previous_headings":"","what":"Isle Royale wolf and moose ‚Äî isle_royale","title":"Isle Royale wolf and moose ‚Äî isle_royale","text":"Data used demonstrate test cross-lagged (vector autoregressive) models","code":""},{"path":"/reference/isle_royale.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Isle Royale wolf and moose ‚Äî isle_royale","text":"","code":"data(isle_royale)"},{"path":"/reference/isle_royale.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Isle Royale wolf and moose ‚Äî isle_royale","text":"Data extracted file \"Data_wolves_moose_Isle_Royale_June2019.csv\" available https://isleroyalewolf.org/data/data/home.html obtained 2023-06-23. Reproduced permission John Vucetich, generated Wolves Moose Isle Royale project.","code":""},{"path":"/reference/isle_royale.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Isle Royale wolf and moose ‚Äî isle_royale","text":"Vucetich, JA Peterson RO. 2012. population biology Isle Royale wolves moose: overview. https://www.isleroyalewolf.org","code":""},{"path":"/reference/list_parameters.html","id":null,"dir":"Reference","previous_headings":"","what":"List fixed and random effects ‚Äî list_parameters","title":"List fixed and random effects ‚Äî list_parameters","text":"list_parameters lists fixed random effects","code":""},{"path":"/reference/list_parameters.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"List fixed and random effects ‚Äî list_parameters","text":"","code":"list_parameters(Obj, verbose = TRUE)"},{"path":"/reference/list_parameters.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"List fixed and random effects ‚Äî list_parameters","text":"Obj Compiled TMB object verbose Boolean, whether print messages terminal","code":""},{"path":"/reference/list_parameters.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"List fixed and random effects ‚Äî list_parameters","text":"Tagged-list fixed random effects, returned invisibly printed screen","code":""},{"path":"/reference/logLik.dsem.html","id":null,"dir":"Reference","previous_headings":"","what":"Marginal log-likelihood ‚Äî logLik.dsem","title":"Marginal log-likelihood ‚Äî logLik.dsem","text":"Extract (marginal) log-likelihood dsem model","code":""},{"path":"/reference/logLik.dsem.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Marginal log-likelihood ‚Äî logLik.dsem","text":"","code":"# S3 method for class 'dsem' logLik(object, ...)"},{"path":"/reference/logLik.dsem.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Marginal log-likelihood ‚Äî logLik.dsem","text":"object Output dsem ... used","code":""},{"path":"/reference/logLik.dsem.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Marginal log-likelihood ‚Äî logLik.dsem","text":"object class logLik attributes val log-likelihood df number parameters Returns object class logLik. attributes \"df\" (degrees freedom) giving number (estimated) fixed effects model, abd \"val\" (value) giving marginal log-likelihood. class allows AIC work expected.","code":""},{"path":"/reference/loo_residuals.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate leave-one-out residuals ‚Äî loo_residuals","title":"Calculate leave-one-out residuals ‚Äî loo_residuals","text":"Calculates quantile residuals using predictive distribution              jacknife (.e., leave-one-predictive distribution)","code":""},{"path":"/reference/loo_residuals.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate leave-one-out residuals ‚Äî loo_residuals","text":"","code":"loo_residuals(   object,   nsim = 100,   what = c(\"quantiles\", \"samples\", \"loo\"),   track_progress = TRUE,   ... )"},{"path":"/reference/loo_residuals.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate leave-one-out residuals ‚Äî loo_residuals","text":"object Output dsem nsim Number simulations use family!=\"fixed\" variable, simulation residuals required. whether return quantile residuals, samples leave-one-predictive distribution data, table leave-one-predictions standard errors latent state track_progress whether track runtimes terminal ... used","code":""},{"path":"/reference/loo_residuals.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate leave-one-out residuals ‚Äî loo_residuals","text":"matrix residuals, order dimensions argument tsdata passed dsem.","code":""},{"path":"/reference/loo_residuals.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate leave-one-out residuals ‚Äî loo_residuals","text":"Conditional quantile residuals calculated using family = \"fixed\", state-variables fixed available measurements hence conditional distribution Dirac delta function.  One alternative use leave-one-residuals, calculate predictive distribution state value dropping associated observation, either use predictive distribution, sample predictive distribution calculate standard quantile distribution given non-fixed family.  appraoch followed . currently implemented  variables follow family = \"fixed\", generalized mix families upon request.","code":""},{"path":"/reference/make_dfa.html","id":null,"dir":"Reference","previous_headings":"","what":"Make text for dynamic factor analysis ‚Äî make_dfa","title":"Make text for dynamic factor analysis ‚Äî make_dfa","text":"Make text string dynamic factor analysis expressed using arrow--lag notation DSEM.","code":""},{"path":"/reference/make_dfa.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Make text for dynamic factor analysis ‚Äî make_dfa","text":"","code":"make_dfa(variables, n_factors, factor_names = paste0(\"F\", seq_len(n_factors)))"},{"path":"/reference/make_dfa.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Make text for dynamic factor analysis ‚Äî make_dfa","text":"variables Character string variables (.e., column names tsdata). n_factors Number factors. factor_names Optional character-vector factor names, must match NA columns tsdata.","code":""},{"path":"/reference/make_dfa.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Make text for dynamic factor analysis ‚Äî make_dfa","text":"text string passed dsem","code":""},{"path":"/reference/make_dsem_ram.html","id":null,"dir":"Reference","previous_headings":"","what":"Make a RAM (Reticular Action Model) ‚Äî make_dsem_ram","title":"Make a RAM (Reticular Action Model) ‚Äî make_dsem_ram","text":"make_dsem_ram converts SEM arrow notation ram describing SEM parameters","code":""},{"path":"/reference/make_dsem_ram.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Make a RAM (Reticular Action Model) ‚Äî make_dsem_ram","text":"","code":"make_dsem_ram(   sem,   times,   variables,   covs = NULL,   quiet = FALSE,   remove_na = TRUE )"},{"path":"/reference/make_dsem_ram.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Make a RAM (Reticular Action Model) ‚Äî make_dsem_ram","text":"sem Specification time-series structural equation model structure including lagged simultaneous effects.  See Details section make_dsem_ram description times character vector listing set times order variables character vector listing set variables covs character vector listing variables estimate standard deviation quiet Boolean indicating whether print messages terminal remove_na Boolean indicating whether remove NA values RAM (default) . remove_NA=FALSE might useful exploration diagnostics advanced users","code":""},{"path":"/reference/make_dsem_ram.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Make a RAM (Reticular Action Model) ‚Äî make_dsem_ram","text":"reticular action module (RAM) describing dependencies","code":""},{"path":"/reference/make_dsem_ram.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Make a RAM (Reticular Action Model) ‚Äî make_dsem_ram","text":"RAM specification using arrow--lag notation line RAM specification make_dsem_ram consists four (unquoted) entries, separated commas: 1. Arrow specification: simple formula, form     -> B , equivalently, B <- regression     coefficient (.e., single-headed directional arrow);     <-> variance <-> B covariance     (.e., double-headed bidirectional arrow). ,     B variable names model. name correspond     observed variable, assumed latent variable.     Spaces can appear freely arrow specification,     can number hyphens arrows, including zero: Thus,     e.g., ->B, --> B, >B legitimate     equivalent. 2. Lag (using positive values): integer specifying whether linkage     simultaneous (lag=0) lagged (e.g., X -> Y, 1, XtoY     indicates X time T affects Y time T+1),     one-headed arrows can lagged. Using positive values indicate lags      matches notational convention used package dynlm. 3. Parameter name: name regression coefficient, variance,     covariance specified arrow. Assigning name two     arrows results equality constraint. Specifying parameter name     NA produces fixed parameter. 4. Value: start value free parameter value fixed parameter.     given NA (simply omitted), model provide default     starting value. Lines may end comment following #. function extends code copied package `sem` licence GPL (>= 2) permission John Fox. Simultaneous autoregressive process simultaneous lagged effects text specifies linkages multivariate time-series model variables \\(\\mathbf X\\) dimensions \\(T \\times C\\) \\(T\\) times \\(C\\) variables. make_dsem_ram parses text build path matrix \\(\\mathbf{P}\\) dimensions \\(TC \\times TC\\), element \\(\\rho_{k_2,k_1}\\) represents impact \\(x_{t_1,c_1}\\) \\(x_{t_2,c_2}\\), \\(k_1=T c_1+t_1\\) \\(k_2=T c_2+t_2\\).  path matrix defines simultaneous equation $$ \\mathrm{vec}(\\mathbf X) = \\mathbf P \\mathrm{vec}(\\mathbf X) + \\mathrm{vec}(\\mathbf \\Delta)$$ \\(\\mathbf \\Delta\\) matrix exogenous errors covariance \\(\\mathbf{V = \\Gamma \\Gamma}^t\\), \\(\\mathbf \\Gamma\\) Cholesky exogenous covariance.  simultaneous autoregressive (SAR) process results \\(\\mathbf X\\) covariance: $$ \\mathrm{Cov}(\\mathbf X) = \\mathbf{(- P)}^{-1} \\mathbf{\\Gamma \\Gamma}^t \\mathbf{((- P)}^{-1})^t $$ Usefully, computing inverse-covariance (precision) matrix \\(\\mathbf{Q = V}^{-1}\\) require inverting \\(\\mathbf{(- P)}\\): $$ \\mathbf{Q} = (\\mathbf{\\Gamma}^{-1} \\mathbf{(- P)})^t \\mathbf{\\Gamma}^{-1} \\mathbf{(- P)} $$ Example: univariate first-order autoregressive model simultaneous autoregressive (SAR) process across variables times allows user specify simutanous effects (effects among variables within year \\(T\\)) lagged effects (effects among variables among years \\(T\\)). one example, consider univariate first-order autoregressive process \\(T=4\\). independent errors.  specified passing  sem = \"X -> X, 1, rho \\n X <-> X, 0, sigma\"  make_dsem_ram. parsed RAM: Rows RAM heads=1 interpreted construct path matrix \\(\\mathbf P\\), column \"\" RAM indicates column number matrix, column \"\" RAM indicates row number matrix: $$ \\mathbf P = \\begin{bmatrix}     0 & 0 & 0 & 0 \\\\     \\rho & 0 & 0 & 0 \\\\     0 & \\rho & 0 & 0 \\\\     0 & 0 & \\rho & 0\\\\     \\end{bmatrix} $$ rows heads=2 interpreted construct Cholesky exogenous covariance \\(\\mathbf \\Gamma\\) column \"parameter\" RAM associates nonzero element two matrices element vector estimated parameters: $$ \\mathbf \\Gamma = \\begin{bmatrix}     \\sigma & 0 & 0 & 0 \\\\     0 & \\sigma & 0 & 0 \\\\     0 & 0 & \\sigma & 0 \\\\     0 & 0 & 0 & \\sigma\\\\     \\end{bmatrix} $$ two estimated parameters \\(\\mathbf \\beta = (\\rho, \\sigma) \\). results covariance: $$ \\mathrm{Cov}(\\mathbf X) = \\sigma^2 \\begin{bmatrix}     1      & \\rho^1              & \\rho^2                        & \\rho^3                  \\\\     \\rho^1 & 1 + \\rho^2          & \\rho^1 (1 + \\rho^2)           & \\rho^2 (1 + \\rho^2)     \\\\     \\rho^2 & \\rho^1 (1 + \\rho^2) & 1 + \\rho^2 + \\rho^4           & \\rho^1 (1 + \\rho^2 + \\rho^4)                 \\\\     \\rho^3 & \\rho^2 (1 + \\rho^2) & \\rho^1 (1 + \\rho^2 + \\rho^4)  & 1 + \\rho^2 + \\rho^4 + \\rho^6 \\\\     \\end{bmatrix} $$ converges stationary covariance AR1 process times \\(t>>1\\): $$ \\mathrm{Cov}(\\mathbf X) = \\frac{\\sigma^2}{1+\\rho^2} \\begin{bmatrix}     1 & \\rho^1 & \\rho^2 & \\rho^3 \\\\     \\rho^1 & 1 & \\rho^1 & \\rho^2 \\\\     \\rho^2 & \\rho^1 & 1 & \\rho^1 \\\\     \\rho^3 & \\rho^2 & \\rho^1 & 1\\\\     \\end{bmatrix} $$ except lower pointwise variance initial times, arises \"boundary effect\". Similarly, arrow--lag notation can used specify SAR representing conventional structural equation model (SEM), cross-lagged (.k.. vector autoregressive) models (VAR), dynamic factor analysis (DFA), many time-series models.","code":""},{"path":"/reference/make_dsem_ram.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Make a RAM (Reticular Action Model) ‚Äî make_dsem_ram","text":"","code":"# Univariate AR1 sem = \"   X -> X, 1, rho   X <-> X, 0, sigma \" make_dsem_ram( sem=sem, variables=\"X\", times=1:4 ) #> $model #>      path      lag name    start parameter first second direction #> [1,] \"X -> X\"  \"1\" \"rho\"   NA    \"1\"       \"X\"   \"X\"    \"1\"       #> [2,] \"X <-> X\" \"0\" \"sigma\" NA    \"2\"       \"X\"   \"X\"    \"2\"       #>  #> $ram #>   heads to from parameter start #> 1     1  2    1         1  <NA> #> 2     1  3    2         1  <NA> #> 3     1  4    3         1  <NA> #> 5     2  1    1         2  <NA> #> 6     2  2    2         2  <NA> #> 7     2  3    3         2  <NA> #> 8     2  4    4         2  <NA> #>  #> $variables #> [1] \"X\" #>  #> $times #> [1] 1 2 3 4 #>  #> attr(,\"class\") #> [1] \"dsem_ram\"  # Univariate AR2 sem = \"   X -> X, 1, rho1   X -> X, 2, rho2   X <-> X, 0, sigma \" make_dsem_ram( sem=sem, variables=\"X\", times=1:4 ) #> $model #>      path      lag name    start parameter first second direction #> [1,] \"X -> X\"  \"1\" \"rho1\"  NA    \"1\"       \"X\"   \"X\"    \"1\"       #> [2,] \"X -> X\"  \"2\" \"rho2\"  NA    \"2\"       \"X\"   \"X\"    \"1\"       #> [3,] \"X <-> X\" \"0\" \"sigma\" NA    \"3\"       \"X\"   \"X\"    \"2\"       #>  #> $ram #>    heads to from parameter start #> 1      1  2    1         1  <NA> #> 2      1  3    2         1  <NA> #> 3      1  4    3         1  <NA> #> 5      1  3    1         2  <NA> #> 6      1  4    2         2  <NA> #> 9      2  1    1         3  <NA> #> 10     2  2    2         3  <NA> #> 11     2  3    3         3  <NA> #> 12     2  4    4         3  <NA> #>  #> $variables #> [1] \"X\" #>  #> $times #> [1] 1 2 3 4 #>  #> attr(,\"class\") #> [1] \"dsem_ram\"  # Bivariate VAR sem = \"   X -> X, 1, XtoX   X -> Y, 1, XtoY   Y -> X, 1, YtoX   Y -> Y, 1, YtoY   X <-> X, 0, sdX   Y <-> Y, 0, sdY \" make_dsem_ram( sem=sem, variables=c(\"X\",\"Y\"), times=1:4 ) #> $model #>      path      lag name   start parameter first second direction #> [1,] \"X -> X\"  \"1\" \"XtoX\" NA    \"1\"       \"X\"   \"X\"    \"1\"       #> [2,] \"X -> Y\"  \"1\" \"XtoY\" NA    \"2\"       \"X\"   \"Y\"    \"1\"       #> [3,] \"Y -> X\"  \"1\" \"YtoX\" NA    \"3\"       \"Y\"   \"X\"    \"1\"       #> [4,] \"Y -> Y\"  \"1\" \"YtoY\" NA    \"4\"       \"Y\"   \"Y\"    \"1\"       #> [5,] \"X <-> X\" \"0\" \"sdX\"  NA    \"5\"       \"X\"   \"X\"    \"2\"       #> [6,] \"Y <-> Y\" \"0\" \"sdY\"  NA    \"6\"       \"Y\"   \"Y\"    \"2\"       #>  #> $ram #>    heads to from parameter start #> 1      1  2    1         1  <NA> #> 2      1  3    2         1  <NA> #> 3      1  4    3         1  <NA> #> 5      1  6    1         2  <NA> #> 6      1  7    2         2  <NA> #> 7      1  8    3         2  <NA> #> 9      1  2    5         3  <NA> #> 10     1  3    6         3  <NA> #> 11     1  4    7         3  <NA> #> 13     1  6    5         4  <NA> #> 14     1  7    6         4  <NA> #> 15     1  8    7         4  <NA> #> 17     2  1    1         5  <NA> #> 18     2  2    2         5  <NA> #> 19     2  3    3         5  <NA> #> 20     2  4    4         5  <NA> #> 21     2  5    5         6  <NA> #> 22     2  6    6         6  <NA> #> 23     2  7    7         6  <NA> #> 24     2  8    8         6  <NA> #>  #> $variables #> [1] \"X\" \"Y\" #>  #> $times #> [1] 1 2 3 4 #>  #> attr(,\"class\") #> [1] \"dsem_ram\"  # Dynamic factor analysis with one factor and two manifest variables # (specifies a random-walk for the factor, and miniscule residual SD) sem = \"   factor -> X, 0, loadings1   factor -> Y, 0, loadings2   factor -> factor, 1, NA, 1   X <-> X, 0, NA, 0.01       # Fix at negligible value   Y <-> Y, 0, NA, 0.01       # Fix at negligible value \" make_dsem_ram( sem=sem, variables=c(\"X\",\"Y\",\"factor\"), times=1:4 ) #> NOTE: adding 1 variances to the model #> $model #>      path                lag name        start  parameter first    second   #> [1,] \"factor -> X\"       \"0\" \"loadings1\" NA     \"1\"       \"factor\" \"X\"      #> [2,] \"factor -> Y\"       \"0\" \"loadings2\" NA     \"2\"       \"factor\" \"Y\"      #> [3,] \"factor -> factor\"  \"1\" NA          \"1\"    \"0\"       \"factor\" \"factor\" #> [4,] \"X <-> X\"           \"0\" NA          \"0.01\" \"0\"       \"X\"      \"X\"      #> [5,] \"Y <-> Y\"           \"0\" NA          \"0.01\" \"0\"       \"Y\"      \"Y\"      #> [6,] \"factor <-> factor\" \"0\" \"V[factor]\" NA     \"3\"       \"factor\" \"factor\" #>      direction #> [1,] \"1\"       #> [2,] \"1\"       #> [3,] \"1\"       #> [4,] \"2\"       #> [5,] \"2\"       #> [6,] \"2\"       #>  #> $ram #>    heads to from parameter start #> 1      1  1    9         1  <NA> #> 2      1  2   10         1  <NA> #> 3      1  3   11         1  <NA> #> 4      1  4   12         1  <NA> #> 5      1  5    9         2  <NA> #> 6      1  6   10         2  <NA> #> 7      1  7   11         2  <NA> #> 8      1  8   12         2  <NA> #> 9      1 10    9         0     1 #> 10     1 11   10         0     1 #> 11     1 12   11         0     1 #> 13     2  1    1         0  0.01 #> 14     2  2    2         0  0.01 #> 15     2  3    3         0  0.01 #> 16     2  4    4         0  0.01 #> 17     2  5    5         0  0.01 #> 18     2  6    6         0  0.01 #> 19     2  7    7         0  0.01 #> 20     2  8    8         0  0.01 #> 21     2  9    9         3  <NA> #> 22     2 10   10         3  <NA> #> 23     2 11   11         3  <NA> #> 24     2 12   12         3  <NA> #>  #> $variables #> [1] \"X\"      \"Y\"      \"factor\" #>  #> $times #> [1] 1 2 3 4 #>  #> attr(,\"class\") #> [1] \"dsem_ram\"  # ARIMA(1,1,0) sem = \"   factor -> factor, 1, rho1 # AR1 component   X -> X, 1, NA, 1          # Integrated component   factor -> X, 0, NA, 1   X <-> X, 0, NA, 0.01      # Fix at negligible value \" make_dsem_ram( sem=sem, variables=c(\"X\",\"factor\"), times=1:4 ) #> NOTE: adding 1 variances to the model #> $model #>      path                lag name        start  parameter first    second   #> [1,] \"factor -> factor\"  \"1\" \"rho1\"      NA     \"1\"       \"factor\" \"factor\" #> [2,] \"X -> X\"            \"1\" NA          \"1\"    \"0\"       \"X\"      \"X\"      #> [3,] \"factor -> X\"       \"0\" NA          \"1\"    \"0\"       \"factor\" \"X\"      #> [4,] \"X <-> X\"           \"0\" NA          \"0.01\" \"0\"       \"X\"      \"X\"      #> [5,] \"factor <-> factor\" \"0\" \"V[factor]\" NA     \"2\"       \"factor\" \"factor\" #>      direction #> [1,] \"1\"       #> [2,] \"1\"       #> [3,] \"1\"       #> [4,] \"2\"       #> [5,] \"2\"       #>  #> $ram #>    heads to from parameter start #> 1      1  6    5         1  <NA> #> 2      1  7    6         1  <NA> #> 3      1  8    7         1  <NA> #> 5      1  2    1         0     1 #> 6      1  3    2         0     1 #> 7      1  4    3         0     1 #> 9      1  1    5         0     1 #> 10     1  2    6         0     1 #> 11     1  3    7         0     1 #> 12     1  4    8         0     1 #> 13     2  1    1         0  0.01 #> 14     2  2    2         0  0.01 #> 15     2  3    3         0  0.01 #> 16     2  4    4         0  0.01 #> 17     2  5    5         2  <NA> #> 18     2  6    6         2  <NA> #> 19     2  7    7         2  <NA> #> 20     2  8    8         2  <NA> #>  #> $variables #> [1] \"X\"      \"factor\" #>  #> $times #> [1] 1 2 3 4 #>  #> attr(,\"class\") #> [1] \"dsem_ram\"  # ARIMA(0,0,1) sem = \"   factor -> X, 0, NA, 1   factor -> X, 1, rho1     # MA1 component   X <-> X, 0, NA, 0.01     # Fix at negligible value \" make_dsem_ram( sem=sem, variables=c(\"X\",\"factor\"), times=1:4 ) #> NOTE: adding 1 variances to the model #> $model #>      path                lag name        start  parameter first    second   #> [1,] \"factor -> X\"       \"0\" NA          \"1\"    \"0\"       \"factor\" \"X\"      #> [2,] \"factor -> X\"       \"1\" \"rho1\"      NA     \"1\"       \"factor\" \"X\"      #> [3,] \"X <-> X\"           \"0\" NA          \"0.01\" \"0\"       \"X\"      \"X\"      #> [4,] \"factor <-> factor\" \"0\" \"V[factor]\" NA     \"2\"       \"factor\" \"factor\" #>      direction #> [1,] \"1\"       #> [2,] \"1\"       #> [3,] \"2\"       #> [4,] \"2\"       #>  #> $ram #>    heads to from parameter start #> 1      1  1    5         0     1 #> 2      1  2    6         0     1 #> 3      1  3    7         0     1 #> 4      1  4    8         0     1 #> 5      1  2    5         1  <NA> #> 6      1  3    6         1  <NA> #> 7      1  4    7         1  <NA> #> 9      2  1    1         0  0.01 #> 10     2  2    2         0  0.01 #> 11     2  3    3         0  0.01 #> 12     2  4    4         0  0.01 #> 13     2  5    5         2  <NA> #> 14     2  6    6         2  <NA> #> 15     2  7    7         2  <NA> #> 16     2  8    8         2  <NA> #>  #> $variables #> [1] \"X\"      \"factor\" #>  #> $times #> [1] 1 2 3 4 #>  #> attr(,\"class\") #> [1] \"dsem_ram\""},{"path":"/reference/parse_path.html","id":null,"dir":"Reference","previous_headings":"","what":"Parse path ‚Äî parse_path","title":"Parse path ‚Äî parse_path","text":"parse_path copied sem::parse.path","code":""},{"path":"/reference/parse_path.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Parse path ‚Äî parse_path","text":"","code":"parse_path(path)"},{"path":"/reference/parse_path.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Parse path ‚Äî parse_path","text":"path text parse","code":""},{"path":"/reference/parse_path.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Parse path ‚Äî parse_path","text":"Tagged-list defining variables direction specified path coefficient","code":""},{"path":"/reference/parse_path.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Parse path ‚Äî parse_path","text":"Copied package `sem` licence GPL (>= 2) permission John Fox","code":""},{"path":"/reference/plot.dsem.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate dsem ‚Äî plot.dsem","title":"Simulate dsem ‚Äî plot.dsem","text":"Plot fitted dsem model","code":""},{"path":"/reference/plot.dsem.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate dsem ‚Äî plot.dsem","text":"","code":"# S3 method for class 'dsem' plot(   x,   y,   edge_label = c(\"name\", \"value\", \"value_and_stars\"),   digits = 2,   style = c(\"igraph\", \"ggraph\"),   ... )"},{"path":"/reference/plot.dsem.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate dsem ‚Äî plot.dsem","text":"x Output dsem y used edge_label Whether plot parameter names, estimated values, estimated values along stars indicating significance 0.05, 0.01, 0.001 levels (based two-sided Wald tests) digits integer indicating number decimal places used style Whether make graph using igraph ggraph ... arguments passed plot.igraph","code":""},{"path":"/reference/plot.dsem.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate dsem ‚Äî plot.dsem","text":"Invisibly returns output graph_from_data_frame passed plot.igraph plotting.","code":""},{"path":"/reference/plot.dsem.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Simulate dsem ‚Äî plot.dsem","text":"function coerces output graph plots graph.","code":""},{"path":"/reference/predict.dsem.html","id":null,"dir":"Reference","previous_headings":"","what":"predictions using dsem ‚Äî predict.dsem","title":"predictions using dsem ‚Äî predict.dsem","text":"Predict variables given new (counterfactual) values data, future past times","code":""},{"path":"/reference/predict.dsem.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"predictions using dsem ‚Äî predict.dsem","text":"","code":"# S3 method for class 'dsem' predict(object, newdata = NULL, type = c(\"link\", \"response\"), ...)"},{"path":"/reference/predict.dsem.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"predictions using dsem ‚Äî predict.dsem","text":"object Output dsem newdata optionally, data frame look variables predict. omitted, fitted data used create predictions. desiring predictions fitted data, user must append rows NAs future times.  Similarly, desiring predictions given counterfactual values time-series data, individual observations can edited keeping observations original fitted values. type type prediction required. default scale linear predictors; alternative \"response\" scale response variable. Thus Poisson-distributed variable default predictions log-intensity type = \"response\" gives predicted intensity. ... used","code":""},{"path":"/reference/predict.dsem.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"predictions using dsem ‚Äî predict.dsem","text":"matrix predicted values dimensions order corresponding argument newdata provided, tsdata . Predictions provided either link response scale, generated re-optimizing random effects condition MLE fixed effects, given new data.","code":""},{"path":"/reference/print.dsem.html","id":null,"dir":"Reference","previous_headings":"","what":"Print fitted dsem object ‚Äî print.dsem","title":"Print fitted dsem object ‚Äî print.dsem","text":"Prints output fitted dsem model","code":""},{"path":"/reference/print.dsem.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print fitted dsem object ‚Äî print.dsem","text":"","code":"# S3 method for class 'dsem' print(x, ...)"},{"path":"/reference/print.dsem.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print fitted dsem object ‚Äî print.dsem","text":"x Output dsem ... used","code":""},{"path":"/reference/print.dsem.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print fitted dsem object ‚Äî print.dsem","text":"return value, called provide clean terminal output calling fitted object terminal.","code":""},{"path":"/reference/residuals.dsem.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate residuals ‚Äî residuals.dsem","title":"Calculate residuals ‚Äî residuals.dsem","text":"Calculate deviance response residuals dsem","code":""},{"path":"/reference/residuals.dsem.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate residuals ‚Äî residuals.dsem","text":"","code":"# S3 method for class 'dsem' residuals(object, type = c(\"deviance\", \"response\"), ...)"},{"path":"/reference/residuals.dsem.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate residuals ‚Äî residuals.dsem","text":"object Output dsem type type residuals compute (option \"deviance\" \"response\" now) ... used","code":""},{"path":"/reference/residuals.dsem.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate residuals ‚Äî residuals.dsem","text":"matrix residuals, order dimensions argument tsdata passed dsem.","code":""},{"path":"/reference/sea_otter.html","id":null,"dir":"Reference","previous_headings":"","what":"Sea otter trophic cascade ‚Äî sea_otter","title":"Sea otter trophic cascade ‚Äî sea_otter","text":"Data used demonstrate test trophic cascades options","code":""},{"path":"/reference/sea_otter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sea otter trophic cascade ‚Äî sea_otter","text":"","code":"data(sea_otter)"},{"path":"/reference/simulate.dsem.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate dsem ‚Äî simulate.dsem","title":"Simulate dsem ‚Äî simulate.dsem","text":"Simulate fitted dsem model","code":""},{"path":"/reference/simulate.dsem.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate dsem ‚Äî simulate.dsem","text":"","code":"# S3 method for class 'dsem' simulate(   object,   nsim = 1,   seed = NULL,   variance = c(\"none\", \"random\", \"both\"),   resimulate_gmrf = FALSE,   ... )"},{"path":"/reference/simulate.dsem.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate dsem ‚Äî simulate.dsem","text":"object Output dsem nsim number simulated data sets seed random seed variance whether ignore uncertainty fixed random effects, include estimation uncertainty random effects, include estimation uncertainty fixed random effects resimulate_gmrf whether resimulate GMRF based estimated simulated random effects (determined argument variance) ... used","code":""},{"path":"/reference/simulate.dsem.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate dsem ‚Äî simulate.dsem","text":"Simulated data, either obj$simulate obj compiled TMB object, first simulating new GMRF calling obj$simulate.","code":""},{"path":"/reference/simulate.dsem.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Simulate dsem ‚Äî simulate.dsem","text":"function conducts parametric bootstrap, .e., simulates new data conditional upon estimated values fixed random effects.  user can optionally simulate new random effects conditional upon estimated covariance, simulate new fixed random effects conditional upon imprecision. Note simulate effect states x_tj measurement measurements fitted using family=\"fixed\", unless resimulate_gmrf=TRUE.  latter case, GMRF resimulated given estimated path coefficients","code":""},{"path":"/reference/stepwise_selection.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate dsem ‚Äî stepwise_selection","title":"Simulate dsem ‚Äî stepwise_selection","text":"Plot fitted dsem model","code":""},{"path":"/reference/stepwise_selection.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate dsem ‚Äî stepwise_selection","text":"","code":"stepwise_selection(model_options, model_shared, quiet = FALSE, ...)"},{"path":"/reference/stepwise_selection.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate dsem ‚Äî stepwise_selection","text":"model_options character-vector containing sem elements included dropped depending upon parsimony model_shared character-vector containing sem elements must included regardless parsimony quiet whether avoid displaying progress terminal ... arguments passed dsem, sem e.g., tsdata, family etc.","code":""},{"path":"/reference/stepwise_selection.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate dsem ‚Äî stepwise_selection","text":"object (list) includes: model string selected SEM model record list showing AIC whether model_options included ","code":""},{"path":"/reference/stepwise_selection.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Simulate dsem ‚Äî stepwise_selection","text":"function conducts stepwise (.e., forwards backwards) model selection using marginal AIC, forcing model elements included selecting among others.","code":""},{"path":"/reference/summary.dsem.html","id":null,"dir":"Reference","previous_headings":"","what":"summarize dsem ‚Äî summary.dsem","title":"summarize dsem ‚Äî summary.dsem","text":"summarize parameters fitted dynamic structural equation model","code":""},{"path":"/reference/summary.dsem.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"summarize dsem ‚Äî summary.dsem","text":"","code":"# S3 method for class 'dsem' summary(object, ...)"},{"path":"/reference/summary.dsem.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"summarize dsem ‚Äî summary.dsem","text":"object Output dsem ... used","code":""},{"path":"/reference/summary.dsem.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"summarize dsem ‚Äî summary.dsem","text":"Returns data.frame summarizing estimated path coefficients, containing columns: path parsed path coefficient lag lag, e.g. 1 means predictor time t effects response time t+1 name Parameter name start Start value supplied, NA otherwise parameter Parameter number first Variable path treated predictor second Variable path treated response direction Whether path one-headed two-headed Estimate Maximum likelihood estimate Std_Error Estimated standard error Hessian matrix z_value Estimate divided Std_Error p_value P-value associated z_value using two-sided Wald test","code":""},{"path":"/reference/summary.dsem.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"summarize dsem ‚Äî summary.dsem","text":"DSEM specified using \"arrow lag\" notation, specifies set path coefficients exogenous variance parameters estimated. Function dsem estimates maximum likelihood value coefficients parameters maximizing log-marginal likelihood.  Standard errors parameters calculated matrix second derivatives log-marginal likelihood (\"Hessian matrix\"). However, many users want associate individual parameters standard errors path coefficients specified using \"arrow lag\" notation. task complicated models path coefficients variance parameters specified share single value priori, assigned name NA hence assumed fixed value priori (coefficients parameters assigned value standard error). summary function therefore compiles MLE coefficients (including duplicating values path coefficients assigned value) standard error estimates, outputs table associates user-supplied path parameter names. also outputs z-score p-value arising two-sided Wald test (.e. comparing estimate divided standard error standard normal distribution).","code":""},{"path":"/reference/vcov.dsem.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract Variance-Covariance Matrix ‚Äî vcov.dsem","title":"Extract Variance-Covariance Matrix ‚Äî vcov.dsem","text":"extract covariance fixed effects, fixed random effects.","code":""},{"path":"/reference/vcov.dsem.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract Variance-Covariance Matrix ‚Äî vcov.dsem","text":"","code":"# S3 method for class 'dsem' vcov(object, which = c(\"fixed\", \"random\", \"both\"), ...)"},{"path":"/reference/vcov.dsem.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract Variance-Covariance Matrix ‚Äî vcov.dsem","text":"object output dsem whether extract covariance among fixed effects, random effects, ... ignored, method compatibility","code":""},{"path":"/reference/vcov.dsem.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract Variance-Covariance Matrix ‚Äî vcov.dsem","text":"square matrix containing estimated covariances among parameter estimates model. dimensions dependend upon argument , determine whether fixed, random effects, outputted.","code":""},{"path":"/news/index.html","id":"dsem-140","dir":"Changelog","previous_headings":"","what":"dsem 1.4.0","title":"dsem 1.4.0","text":"Adding option lower upper bounds Adding stepwise_selection automated stepwise model selection Adding plot option use ggraph alternative previous igraph option Adding convert_equations extend sem::specifyEquations simplify specification large models","code":""},{"path":"/news/index.html","id":"dsem-130","dir":"Changelog","previous_headings":"","what":"dsem 1.3.0","title":"dsem 1.3.0","text":"CRAN release: 2024-07-22 Adding option specify constant marginal variance, alternative existing calculation results constant conditional variance changing marginal variance along causal graph","code":""},{"path":"/news/index.html","id":"dsem-121","dir":"Changelog","previous_headings":"","what":"dsem 1.2.1","title":"dsem 1.2.1","text":"CRAN release: 2024-04-02 removing checkDepPackageVersion(dep_pkg=\"Matrix\", this_pkg=\"TMB\") .onLoad() requested K. Kristensen","code":""},{"path":"/news/index.html","id":"dsem-120","dir":"Changelog","previous_headings":"","what":"dsem 1.2.0","title":"dsem 1.2.0","text":"CRAN release: 2024-03-31 Adding option specify covariance via argument covs Adding options specify gmrf_parameterization=‚Äúprojection‚Äù Adding vigette outlining fit dynamic factor analysis Fix bug arising tsdata two columns sharing single variable name Adding make_dfa helper function Updating bering_sea dataset include extra year cold-pool, changing vignette match published specification results Updating lag indexing Klein-model vignette use positive values lags, updating saved MCMC results match corrected specification","code":""},{"path":"/news/index.html","id":"dsem-110","dir":"Changelog","previous_headings":"","what":"dsem 1.1.0","title":"dsem 1.1.0","text":"CRAN release: 2024-02-17 Adding option specify covariance Gamma","code":""},{"path":"/news/index.html","id":"dsem-102","dir":"Changelog","previous_headings":"","what":"dsem 1.0.2","title":"dsem 1.0.2","text":"CRAN release: 2024-02-02 Eliminate eval usage Add codecov Action badge Change default behavior variables tsdata standard deviation default","code":""},{"path":"/news/index.html","id":"dsem-101","dir":"Changelog","previous_headings":"","what":"dsem 1.0.1","title":"dsem 1.0.1","text":"CRAN release: 2024-01-18 Fix bug simulate.dsem keep changing interface dsem Update CITATION indicate accepted paper Remove fit_tmb eliminate cryptic warning messages simplify code","code":""},{"path":"/news/index.html","id":"dsem-100","dir":"Changelog","previous_headings":"","what":"dsem 1.0.0","title":"dsem 1.0.0","text":"CRAN release: 2023-12-08 Initial public release","code":""}]
